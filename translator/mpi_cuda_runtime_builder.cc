// Licensed under the BSD license. See LICENSE.txt for more details.

#include "translator/mpi_cuda_runtime_builder.h"

namespace sb = SageBuilder;
namespace si = SageInterface;
namespace ru = physis::translator::rose_util;

namespace physis {
namespace translator {

SgExpression *MPICUDARuntimeBuilder::BuildGridBaseAddr(
    SgExpression *gvref, SgType *point_type) {
  return ReferenceRuntimeBuilder::BuildGridBaseAddr(gvref, point_type);
}


SgFunctionCallExp *BuildGridGetDev(SgExpression *grid_var) {
  SgFunctionSymbol *fs
      = si::lookupFunctionSymbolInParentScopes("__PSGridGetDev");
  SgFunctionCallExp *fc =
      sb::buildFunctionCallExp(fs, sb::buildExprListExp(grid_var));
  return fc;
}

SgFunctionCallExp *BuildGetLocalSize(SgExpression *dim) {
  SgFunctionSymbol *fs
      = si::lookupFunctionSymbolInParentScopes("__PSGetLocalSize");
  SgFunctionCallExp *fc =
      sb::buildFunctionCallExp(fs, sb::buildExprListExp(dim));
  return fc;
}  
SgFunctionCallExp *BuildGetLocalOffset(SgExpression *dim) {
  SgFunctionSymbol *fs
      = si::lookupFunctionSymbolInParentScopes("__PSGetLocalOffset");
  SgFunctionCallExp *fc =
      sb::buildFunctionCallExp(fs, sb::buildExprListExp(dim));
  return fc;
}

SgFunctionCallExp *BuildDomainShrink(SgExpression *dom,
                                     SgExpression *width) {
  SgFunctionSymbol *fs
      = si::lookupFunctionSymbolInParentScopes("__PSDomainShrink");
  SgFunctionCallExp *fc =
      sb::buildFunctionCallExp(
          fs, sb::buildExprListExp(dom, width));
  return fc;
}

SgExpression *BuildStreamBoundaryKernel(int idx) {
  SgVarRefExp *inner_stream = sb::buildVarRefExp("stream_boundary_kernel");
  return sb::buildPntrArrRefExp(inner_stream, sb::buildIntVal(idx));
}

SgExprListExp *MPICUDARuntimeBuilder::BuildKernelCallArgList(
    StencilMap *stencil,
    SgExpressionPtrList &index_args,
    SgFunctionParameterList *run_kernel_params) {
  return cuda_rt_builder_->BuildKernelCallArgList(
      stencil, index_args, run_kernel_params);
}

SgIfStmt *MPICUDARuntimeBuilder::BuildDomainInclusionCheck(
    const vector<SgVariableDeclaration*> &indices,
    SgInitializedName *dom_arg, SgStatement *true_stmt) {
  return cuda_rt_builder_->BuildDomainInclusionCheck(
      indices, dom_arg, true_stmt);
}

SgFunctionParameterList *MPICUDARuntimeBuilder::BuildRunKernelFuncParameterList(
    StencilMap *stencil) {
  SgFunctionParameterList *params =
      cuda_rt_builder_->BuildRunKernelFuncParameterList(stencil);
  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    si::appendArg(
        params,
        sb::buildInitializedName(
            "offset" + toString(i), sb::buildIntType()));
  }
  return params;
}

// This is almost equivalent as CUDATranslator::BuildRunKernel, except
// for having offset.
SgFunctionDeclaration *MPICUDARuntimeBuilder::BuildRunKernelFunc(
    StencilMap *stencil) {
#if 0  
  SgFunctionParameterList *params = sb::buildFunctionParameterList();
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);
  SgInitializedName *dom_arg = NULL;
  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();
  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    si::appendArg(params,
                  sb::buildInitializedName("offset" + toString(i),
                                           sb::buildIntType()));
  }
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = sb::buildInitializedName(
        vars[0]->get_name(), vars[0]->get_type());
    SgType *type = arg->get_type();
    LOG_DEBUG() << "type: " << type->unparseToString() << "\n";
    if (Domain::isDomainType(type)) {
      if (!dom_arg) { dom_arg = arg; }
    } else if (GridType::isGridType(type)) {
      SgType *gt = BuildOnDeviceGridType(
          ru::GetASTAttribute<GridType>(type));
      arg->set_type(gt);
      // skip the grid index
      ++member;
    }
    si::appendArg(params, arg);
  }
  PSAssert(dom_arg);

  LOG_INFO() << "Declaring and defining function named "
             << stencil->GetRunName() << "\n";
  SgFunctionDeclaration *run_func =
      sb::buildDefiningFunctionDeclaration(stencil->GetRunName(),
                                           sb::buildVoidType(),
                                           params, gs_);
  
  si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
  run_func->get_functionModifier().setCudaKernel();
  vector<SgVariableDeclaration*> indices;
  SgBasicBlock *func_body = BuildRunKernelFuncBody(stencil, params, indices);
  rose_util::ReplaceFuncBody(run_func, func_body);  
  rose_util::AddASTAttribute(run_func,
                             new RunKernelAttribute(stencil));
  return run_func;
#else
  return cuda_rt_builder_->BuildRunKernelFunc(stencil);
#endif
}

#if 1
SgBasicBlock *MPICUDARuntimeBuilder::BuildRunKernelFuncBody(
    StencilMap *stencil, SgFunctionParameterList *param,
    vector<SgVariableDeclaration*> &indices) {
  return cuda_rt_builder_->BuildRunKernelFuncBody(
      stencil, param, indices);
}
#else
// This is the same as CUDATranslator::BuildRunKernelBody, except for
// this version needs to add offsets to the x and y indices.
SgBasicBlock* MPICUDARuntimeBuilder::BuildRunKernelFuncBody(
    StencilMap *stencil,
    SgFunctionParameterList *param,
    vector<SgVariableDeclaration*> &indices) {
  LOG_DEBUG() << __FUNCTION__;
  SgInitializedName *dom_arg = param->get_args()[0];  
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  int dim = stencil->getNumDim();  
  SgExpression *min_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_min"));
  SgExpression *max_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_max"));
  vector<SgExpression*> offset_exprs;
  for (int i = 0; i < dim-1; ++i) {
    offset_exprs.push_back(sb::buildVarRefExp("offset" + toString(i)));
  }
  
  SgExpressionPtrList index_args;
  if (dim < 3) {
    LOG_ERROR() << "not supported yet.\n";
  } else if (dim == 3) {
    // x = blockIdx.x * blockDim.x + threadIdx.x + offset.x;

    SgAssignInitializer *x_init =
        sb::buildAssignInitializer(
            Add(Add(Mul(ru::BuildCudaIdxExp(ru::kBlockIdxX),
                        ru::BuildCudaIdxExp(ru::kBlockDimX)),
                    ru::BuildCudaIdxExp(ru::kThreadIdxX)),
                offset_exprs[0]));

    // y = blockIdx.y * blockDim.y + threadIdx.y + offset.y;    
    SgAssignInitializer *y_init = 
        sb::buildAssignInitializer(
            Add(Add(Mul(ru::BuildCudaIdxExp(ru::kBlockIdxY),
                        ru::BuildCudaIdxExp(ru::kBlockDimY)),
                    ru::BuildCudaIdxExp(ru::kThreadIdxY)),
                offset_exprs[1]));
        
    SgVariableDeclaration *x_index = sb::buildVariableDeclaration
        ("x", sb::buildIntType(), x_init, block);
    SgVariableDeclaration *y_index = sb::buildVariableDeclaration
        ("y", sb::buildIntType(), y_init, block);
    SgVariableDeclaration *z_index = sb::buildVariableDeclaration
        ("z", sb::buildIntType(), NULL, block);
    rose_util::AddASTAttribute<RunKernelIndexVarAttribute>(
        x_index, new RunKernelIndexVarAttribute(1));
    rose_util::AddASTAttribute<RunKernelIndexVarAttribute>(
        y_index, new RunKernelIndexVarAttribute(2));
    rose_util::AddASTAttribute<RunKernelIndexVarAttribute>(
        z_index, new RunKernelIndexVarAttribute(3));
    si::appendStatement(x_index, block);
    si::appendStatement(y_index, block);
    index_args.push_back(sb::buildVarRefExp(x_index));
    index_args.push_back(sb::buildVarRefExp(y_index));

    SgVariableDeclaration *loop_index = z_index;
    SgExpression *loop_begin =
        ArrayRef(min_field, Int(2));
    SgStatement *loop_init = sb::buildAssignStatement(
        sb::buildVarRefExp(loop_index),
        loop_begin);
    SgExpression *loop_end =
        ArrayRef(max_field,
                 Int(2));
    SgStatement *loop_test = sb::buildExprStatement(
        sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                            loop_end));
    index_args.push_back(sb::buildVarRefExp(loop_index));

    SgVariableDeclaration* t[] = {x_index, y_index};
    vector<SgVariableDeclaration*> range_checking_idx(t, t + 2);
    si::appendStatement(
        BuildDomainInclusionCheck(
            range_checking_idx, dom_arg,
            sb::buildReturnStmt()),
        block);
    si::appendStatement(loop_index, block);

    SgExpression *loop_incr =
        sb::buildPlusPlusOp(sb::buildVarRefExp(loop_index));
    SgFunctionCallExp *kernel_call
        = BuildKernelCall(stencil, index_args, param);
    SgBasicBlock *loop_body =
        sb::buildBasicBlock(sb::buildExprStatement(kernel_call));
    SgStatement *loop
        = sb::buildForStatement(loop_init, loop_test,
                                loop_incr, loop_body);
    si::appendStatement(loop, block);
    rose_util::AddASTAttribute(loop, new RunKernelLoopAttribute(3));
  }

  return block;
}
#endif

SgScopeStatement *MPICUDARuntimeBuilder::BuildKernelCallPreamble1D(
    StencilMap *stencil,    
    SgInitializedName *dom_arg,
    SgFunctionParameterList *param,    
    vector<SgVariableDeclaration*> &indices,
    SgScopeStatement *call_site) {
  LOG_ERROR() << "Not implemented yet\n";
  PSAbort(1);
  return call_site;
}   

SgScopeStatement *MPICUDARuntimeBuilder::BuildKernelCallPreamble2D(
    StencilMap *stencil,    
    SgInitializedName *dom_arg,
    SgFunctionParameterList *param,    
    vector<SgVariableDeclaration*> &indices,
    SgScopeStatement *call_site) {
  LOG_ERROR() << "Not implemented yet\n";
  PSAbort(1);
  return NULL;
}   

// TODO: Different from CUDA builder?
SgScopeStatement *MPICUDARuntimeBuilder::BuildKernelCallPreamble3D(
    StencilMap *stencil,
    SgInitializedName *dom_arg,
    SgFunctionParameterList *param,
    vector<SgVariableDeclaration*> &indices,
    SgScopeStatement *call_site) {
  int dim = 3;
  SgExpression *loop_begin =
      BuildDomMinRef(sb::buildVarRefExp(dom_arg), dim);
  SgStatement *loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(indices.back()), loop_begin);
  SgExpression *loop_end =
      BuildDomMaxRef(sb::buildVarRefExp(dom_arg), dim);
  SgStatement *loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(indices.back()),
                          loop_end));

  SgVariableDeclaration* t[] = {
    stencil->IsRedBlackVariant() ? NULL: indices[0], indices[1]};
  vector<SgVariableDeclaration*> range_checking_idx(t, t + 2);
  si::appendStatement(
      BuildDomainInclusionCheck(
          range_checking_idx, dom_arg, sb::buildReturnStmt()),
      call_site);

  SgExpression *loop_incr =
      sb::buildPlusPlusOp(sb::buildVarRefExp(indices.back()));
  SgBasicBlock *kernel_call_block = sb::buildBasicBlock();
  SgStatement *loop
      = sb::buildForStatement(loop_init, loop_test,
                              loop_incr, kernel_call_block);
  si::appendStatement(loop, call_site);
  rose_util::AddASTAttribute(
      loop,
      new RunKernelLoopAttribute(dim));

  if (stencil->IsRedBlackVariant()) {
    SgExpression *rb_offset_init =
        Add(sb::buildVarRefExp(indices[0]),
            sb::buildBitAndOp(
                Add(Var(indices[1]),
                    sb::buildVarRefExp(indices[2]),
                    sb::buildVarRefExp(param->get_args().back())),
                Int(1)));
    SgVariableDeclaration *x_index_rb =
        sb::buildVariableDeclaration(
            indices[0]->get_variables()[0]->get_name() + "_rb",
            sb::buildIntType(),
            sb::buildAssignInitializer(rb_offset_init));
    indices[0] = x_index_rb;
    si::appendStatement(
        x_index_rb, kernel_call_block);
    SgVariableDeclaration* t[] = {x_index_rb};
    vector<SgVariableDeclaration*> range_checking_idx(t, t + 1);
    si::appendStatement(
        BuildDomainInclusionCheck(
            range_checking_idx, dom_arg, sb::buildContinueStmt()),
        kernel_call_block);
  }
  
  return kernel_call_block;
}

SgScopeStatement *MPICUDARuntimeBuilder::BuildKernelCallPreamble(
    StencilMap *stencil,
    SgInitializedName *dom_arg,
    SgFunctionParameterList *param,    
    vector<SgVariableDeclaration*> &indices,
    SgScopeStatement *call_site) {
  return cuda_rt_builder_->BuildKernelCallPreamble(
      stencil, dom_arg, param, indices, call_site);
}

void MPICUDARuntimeBuilder::BuildKernelIndices(
    StencilMap *stencil,
    SgBasicBlock *call_site,
    vector<SgVariableDeclaration*> &indices) {
  cuda_rt_builder_->BuildKernelIndices(stencil, call_site, indices);
  // TODO: add "+ offset"
}

SgType *MPICUDARuntimeBuilder::BuildOnDeviceGridType(GridType *gt) {
  return cuda_rt_builder_->BuildOnDeviceGridType(gt);
}

} // namespace translator
} // namespace physis
