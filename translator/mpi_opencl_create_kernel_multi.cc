#include "translator/mpi_opencl_translator.h"
#include "translator/translation_context.h"
#include "translator/translation_util.h"
#include "translator/rose_util.h"
#include "translator/rose_ast_attribute.h"

namespace pu = physis::util;
namespace sb = SageBuilder;
namespace si = SageInterface;

namespace physis {
namespace translator {

SgFunctionDeclarationPtrVector
MPIOpenCLTranslator::BuildRunMultiStreamBoundaryKernel(
    StencilMap *stencil) {
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  std::vector<SgFunctionDeclaration*> run_funcs;

  for (int i = 0; i < stencil->getNumDim(); ++i) {
    for (int j = 0; j < 2; ++j) {
      bool fw = j;
      string name = stencil->getRunName() + GetBoundarySuffix(i, fw);
      LOG_INFO() << "Generating global function: " << name << "\n";
      SgFunctionParameterList *params = sb::buildFunctionParameterList();
      SgInitializedName *grid_arg = NULL;
      SgInitializedName *dom_arg = NULL;
      BuildFunctionParamList(param_struct_def, params,
                             grid_arg, dom_arg);
      PSAssert(dom_arg);
      SgFunctionDeclaration *run_func =
          sb::buildDefiningFunctionDeclaration(
              name, sb::buildVoidType(),
              params, global_scope_);
      si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
      SgBasicBlock *func_body = BuildRunMultiStreamBoundaryKernelBody(
          stencil, grid_arg, dom_arg, i, j);
      si::appendStatement(func_body, run_func->get_definition());

      // Add "__kernel" modifier to __PSStencilRun_kernel
      SgFunctionModifier &modifier = run_func->get_functionModifier();
      modifier.setOpenclKernel();

      // Add macro and mark this function as inner device
      add_macro_mark_function_inner_device(run_func);

      run_funcs.push_back(run_func);
    }
  }
  return run_funcs;
}

SgBasicBlock* MPIOpenCLTranslator::BuildRunMultiStreamBoundaryKernelBody(
    StencilMap *stencil,
    SgInitializedName *grid_arg,
    SgInitializedName *dom_arg, int dim, bool fw) {
  LOG_DEBUG() << "Generating run boundary kernel body\n";
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  SgExpression *min_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_min"));
  SgExpression *max_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_max"));
  
  SgExpressionPtrList index_args;
  PSAssert(stencil->getNumDim() == 3);

  // Construct device innder grid and domain
  Define_and_Construct_griddom_in_device(stencil, dom_arg, block);

  SgVariableDeclaration *x_index = sb::buildVariableDeclaration
      ("x", sb::buildIntType(), NULL, block);
  SgVariableDeclaration *y_index = sb::buildVariableDeclaration
      ("y", sb::buildIntType(), NULL, block);
  SgVariableDeclaration *z_index = sb::buildVariableDeclaration
      ("z", sb::buildIntType(), NULL, block);

  si::appendStatement(x_index, block);    
  si::appendStatement(y_index, block);
  si::appendStatement(z_index, block);

  index_args.push_back(sb::buildVarRefExp(x_index));
  index_args.push_back(sb::buildVarRefExp(y_index));
  index_args.push_back(sb::buildVarRefExp(z_index));  

  SgVariableDeclaration *loop_index = x_index;
  SgStatement *loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),
      sb::buildAddOp(
          BuildFunctionCall(
              "get_local_id", sb::buildIntVal(0)
                            ),
          sb::buildPntrArrRefExp(
              min_field,
              sb::buildIntVal(0)
                                 )
                     )
                                                    );
  SgStatement *loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildPntrArrRefExp(max_field,
                                                 sb::buildIntVal(0))));
  SgExpression *loop_incr =
      sb::buildPlusAssignOp(
          sb::buildVarRefExp(loop_index),
          BuildFunctionCall(
              "get_local_size", sb::buildIntVal(0)
                            )
                            );

  SgBasicBlock *loop_body = sb::buildBasicBlock();
  SgExprListExp *kernel_args=
      BuildKernelCallArgList(stencil, index_args);
  string kernel_name = stencil->getKernel()->get_name()
      + GetBoundarySuffix(dim, fw);
  SgFunctionDeclaration *kernel =
      sb::buildNondefiningFunctionDeclaration(
          kernel_name,
          stencil->getKernel()->get_type()->get_return_type(),
          stencil->getKernel()->get_parameterList(),
          global_scope_);
  SgFunctionCallExp *kernel_call =
      sb::buildFunctionCallExp(sb::buildFunctionRefExp(kernel), kernel_args);
  si::appendStatement(
      sb::buildExprStatement(kernel_call),
      loop_body);

  SgStatement *loop
      = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);

  // Creates doubly nested loops with y and z dimensions
  for (int i = 1; i <= 2; i++) {
    SgExpression *exp_local_id = NULL;
    SgExpression *exp_local_size = NULL;
    if (i == 1) {
      loop_index = y_index;
    } else if (i == 2) {
      loop_index = z_index;
    }

    exp_local_id = BuildFunctionCall("get_local_id", sb::buildIntVal(i));
    exp_local_size = BuildFunctionCall("get_local_size", sb::buildIntVal(i));

    loop_init = sb::buildAssignStatement(
        sb::buildVarRefExp(loop_index),
        sb::buildAddOp(exp_local_id,
                       sb::buildPntrArrRefExp(min_field,
                                              sb::buildIntVal(i))));
    loop_test = sb::buildExprStatement(
        sb::buildLessThanOp(
            sb::buildVarRefExp(loop_index),
            sb::buildPntrArrRefExp(max_field, sb::buildIntVal(i))));
    loop_incr = sb::buildPlusAssignOp(
        sb::buildVarRefExp(loop_index), exp_local_size);
    loop = sb::buildForStatement(loop_init, loop_test, loop_incr, loop);
  }
  si::appendStatement(loop, block);

  return block;
}



} // namespace translator
} // namespace physis
