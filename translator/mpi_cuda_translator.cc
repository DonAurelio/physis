// Copyright 2011, Tokyo Institute of Technology.
// All rights reserved.
//
// This file is distributed under the license described in
// LICENSE.txt.
//
// Author: Naoya Maruyama (naoya@matsulab.is.titech.ac.jp)

#include "translator/mpi_cuda_translator.h"

#include "translator/translation_context.h"
#include "translator/translation_util.h"
#include "translator/mpi_runtime_builder.h"
#include "translator/mpi_cuda_runtime_builder.h"
#include "translator/reference_runtime_builder.h"
#include "translator/cuda_runtime_builder.h"
#include "translator/SageBuilderEx.h"
#include "translator/cuda_builder.h"
#include "translator/rose_util.h"
#include "translator/runtime_builder.h"
#include "translator/mpi_cuda_optimizer.h"
#include "translator/rose_ast_attribute.h"

namespace pu = physis::util;
namespace sb = SageBuilder;
namespace si = SageInterface;
namespace sbx = physis::translator::SageBuilderEx;

namespace physis {
namespace translator {

std::string MPICUDATranslator::GetBoundarySuffix(int dim, bool fw) {
  return boundary_suffix_ + "_" +
      toString(dim+1) + "_" + (fw ? "fw" : "bw");
}

std::string MPICUDATranslator::GetBoundarySuffix() {
  return boundary_suffix_;
}

MPICUDATranslator::MPICUDATranslator(const Configuration &config)
    : MPITranslator(config),
      cuda_trans_(new CUDATranslator(config)),
      boundary_kernel_width_name_("halo_width"),
      inner_prefix_("_inner"),
      boundary_suffix_("_boundary") {  
  grid_create_name_ = "__PSGridNewMPI";
  target_specific_macro_ = "PHYSIS_MPI_CUDA";
  flag_multistream_boundary_ = false;
  const pu::LuaValue *lv =
      config.Lookup(Configuration::MULTISTREAM_BOUNDARY);
  if (lv) {
    PSAssert(lv->get(flag_multistream_boundary_));
  }
  if (flag_multistream_boundary_) {
    LOG_INFO() << "Multistream boundary enabled\n";
  }
}

MPICUDATranslator::~MPICUDATranslator() {
  delete cuda_trans_;
}

void MPICUDATranslator::SetUp(SgProject *project,
                              TranslationContext *context) {
  MPITranslator::SetUp(project, context);
  LOG_DEBUG() << "Parent setup done\n";
  cuda_trans_->SetUp(project, context);
  LOG_DEBUG() << "cuda_trans_ setup done\n";
}

void MPICUDATranslator::Finish() {
  cuda_trans_->Finish();
  MPITranslator::Finish();
}

// This is the same as CUDATranslator::BuildRunKernelBody, except for
// this version needs to add offsets to the x and y indices.
SgBasicBlock* MPICUDATranslator::BuildRunKernelBody(
    StencilMap *stencil,
    SgInitializedName *dom_arg) {
  LOG_DEBUG() << __FUNCTION__;
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  int dim = stencil->getNumDim();  
  SgExpression *domain = sb::buildVarRefExp(dom_arg);
  SgExpression *min_field = BuildDomMinRef(domain);
  SgExpression *max_field = BuildDomMaxRef(domain);
  vector<SgExpression*> offset_exprs;
  for (int i = 0; i < dim-1; ++i) {
    offset_exprs.push_back(sb::buildVarRefExp("offset" + toString(i)));
  }
  
  SgExpressionPtrList index_args;
  if (dim < 3) {
    LOG_ERROR() << "not supported yet.\n";
  } else if (dim == 3) {
    SgVariableDeclaration *x_index = sb::buildVariableDeclaration
        ("x", sb::buildIntType(), NULL, block);
    SgVariableDeclaration *y_index = sb::buildVariableDeclaration
        ("y", sb::buildIntType(), NULL, block);
    SgVariableDeclaration *z_index = sb::buildVariableDeclaration
        ("z", sb::buildIntType(), NULL, block);
    block->append_statement(x_index);    
    block->append_statement(y_index);
    index_args.push_back(sb::buildVarRefExp(x_index));
    index_args.push_back(sb::buildVarRefExp(y_index));

    // x = blockIdx.x * blockDim.x + threadIdx.x + offset.x;
    x_index->reset_initializer(
        sb::buildAssignInitializer(
            sb::buildAddOp(
                sb::buildAddOp(sb::buildMultiplyOp(
                    sbx::buildCudaIdxExp(sbx::kBlockIdxX),
                    sbx::buildCudaIdxExp(sbx::kBlockDimX)),
                               sbx::buildCudaIdxExp(sbx::kThreadIdxX)),
                offset_exprs[0])));
    // y = blockIdx.y * blockDim.y + threadIdx.y + offset.y;
    y_index->reset_initializer(
        sb::buildAssignInitializer(
            sb::buildAddOp(
                sb::buildAddOp(sb::buildMultiplyOp(
                    sbx::buildCudaIdxExp(sbx::kBlockIdxY),
                    sbx::buildCudaIdxExp(sbx::kBlockDimY)),
                               sbx::buildCudaIdxExp(sbx::kThreadIdxY)),
                offset_exprs[1])));
    SgVariableDeclaration *loop_index = z_index;
    SgStatement *loop_init = sb::buildAssignStatement(
        sb::buildVarRefExp(loop_index),
        sb::buildPntrArrRefExp(min_field, sb::buildIntVal(2)));
    SgStatement *loop_test = sb::buildExprStatement(
        sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                            sb::buildPntrArrRefExp(max_field,
                                                   sb::buildIntVal(2))));
    index_args.push_back(sb::buildVarRefExp(loop_index));

    SgVariableDeclaration* t[] = {x_index, y_index};
    vector<SgVariableDeclaration*> range_checking_idx(t, t + 2);
    block->append_statement(
        cuda_trans_->BuildDomainInclusionCheck(range_checking_idx, domain));
    
    block->append_statement(loop_index);

    SgExpression *loop_incr =
        sb::buildPlusPlusOp(sb::buildVarRefExp(loop_index));
    SgFunctionCallExp *kernel_call
        = cuda_trans_->BuildKernelCall(stencil, index_args);
    SgBasicBlock *loop_body =
        sb::buildBasicBlock(sb::buildExprStatement(kernel_call));
    SgStatement *loop
        = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);
    block->append_statement(loop);
  }

  return block;
}

SgBasicBlock* MPICUDATranslator::BuildRunInteriorKernelBody(
    StencilMap *stencil, SgInitializedName *dom_arg) {
  LOG_DEBUG() << "Generating run stencil interior kernel body\n";  

  // Reuse BuildRunKernelBody function, and then redirect calls to
  // the inner kernel function
  
  SgBasicBlock *body = BuildRunKernelBody(stencil, dom_arg);
  const std::string &normal_kernel_name = stencil->getKernel()->get_name();
  const std::string &inner_kernel_name = normal_kernel_name 
                                         + inner_prefix_;
  LOG_DEBUG() << "normal kernel name: " << normal_kernel_name << "\n";
  LOG_DEBUG() << "inner kernel name: " << inner_kernel_name << "\n";
  SgFunctionDeclaration *inner_kernel =
      sb::buildNondefiningFunctionDeclaration(
          inner_kernel_name,
          stencil->getKernel()->get_type()->get_return_type(),
          stencil->getKernel()->get_parameterList(),
          global_scope_);
  
  rose_util::RedirectFunctionCalls
      (body, normal_kernel_name, sb::buildFunctionRefExp(inner_kernel));
  return body;
}

SgBasicBlock* MPICUDATranslator::BuildRunBoundaryKernelBody(
    StencilMap *stencil, SgInitializedName *dom_arg) {
  LOG_DEBUG() << "Generating run boundary kernel body\n";
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  int dim = stencil->getNumDim();  
  SgExpression *domain = sb::buildVarRefExp(dom_arg);
  SgExpression *min_field = BuildDomMinRef(domain);
  SgExpression *max_field = BuildDomMaxRef(domain);
  SgExpression *width = sb::buildVarRefExp(boundary_kernel_width_name_);
  vector<SgExpression*> offset_exprs;
  for (int i = 0; i < dim-1; ++i) {
    offset_exprs.push_back(sb::buildVarRefExp("offset" + toString(i)));
  }
  
  SgExpressionPtrList index_args;
  if (dim < 3) {
    LOG_ERROR() << "not supported yet.\n";
    PSAbort(1);
  }

  SgVariableDeclaration *x_index = sb::buildVariableDeclaration
      ("x", sb::buildIntType(), NULL, block);
  SgVariableDeclaration *y_index = sb::buildVariableDeclaration
      ("y", sb::buildIntType(), NULL, block);
  SgVariableDeclaration *z_index = sb::buildVariableDeclaration
      ("z", sb::buildIntType(), NULL, block);

  block->append_statement(x_index);    
  block->append_statement(y_index);

  index_args.push_back(sb::buildVarRefExp(x_index));
  index_args.push_back(sb::buildVarRefExp(y_index));

  // x = blockIdx.x * blockDim.x + threadIdx.x;
  SgExpression *dom_min_z = sb::buildPntrArrRefExp(min_field,
                                                   sb::buildIntVal(2));
  SgExpression *dom_max_z = sb::buildPntrArrRefExp(max_field,
                                                   sb::buildIntVal(2));
  x_index->reset_initializer(
      sb::buildAssignInitializer(
          sb::buildAddOp(
              sb::buildAddOp(sb::buildMultiplyOp(
                  sbx::buildCudaIdxExp(sbx::kBlockIdxX),
                  sbx::buildCudaIdxExp(sbx::kBlockDimX)),
                             sbx::buildCudaIdxExp(sbx::kThreadIdxX)),
              offset_exprs[0])));
      

  // y = blockIdx.y * blockDim.y + threadIdx.y;
  y_index->reset_initializer(
      sb::buildAssignInitializer(
          sb::buildAddOp(
              sb::buildAddOp(sb::buildMultiplyOp(
                  sbx::buildCudaIdxExp(sbx::kBlockIdxY),
                  sbx::buildCudaIdxExp(sbx::kBlockDimY)),
                             sbx::buildCudaIdxExp(sbx::kThreadIdxY)),
              offset_exprs[1])));
  
  SgVariableDeclaration *loop_index = z_index;      
  SgStatement *loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index), dom_min_z);
  SgStatement *loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildAddOp(dom_min_z, width)));
  
  index_args.push_back(sb::buildVarRefExp(loop_index));

  SgVariableDeclaration* t[] = {x_index, y_index};
  vector<SgVariableDeclaration*> range_checking_idx(t, t + 2);
    
  block->append_statement(
      cuda_trans_->BuildDomainInclusionCheck(range_checking_idx, domain));
    
  block->append_statement(loop_index);

  SgExpression *loop_incr =
      sb::buildPlusPlusOp(sb::buildVarRefExp(loop_index));
  SgFunctionCallExp *kernel_call
      = cuda_trans_->BuildKernelCall(stencil, index_args);
  SgBasicBlock *loop_body = sb::buildBasicBlock(
      sb::buildExprStatement(kernel_call));
  SgStatement *loop
      = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);
  block->append_statement(loop);

  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),  sb::buildAddOp(dom_min_z, width));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildSubtractOp(dom_max_z, width)));
  loop = sb::buildForStatement(loop_init, loop_test,
                               loop_incr, loop_body);
  block->append_statement(BuildDomainInclusionInnerCheck(
      range_checking_idx, domain, width, loop));

  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index), sb::buildSubtractOp(dom_max_z,
                                                          width));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          dom_max_z));
  loop = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);
  block->append_statement(loop);

  return block;
}

SgIfStmt *MPICUDATranslator::BuildDomainInclusionInnerCheck(
    const vector<SgVariableDeclaration*> &indices,
    SgExpression *dom_ref, SgExpression *width,
    SgStatement *ifclause) const {
  SgExpression *test_all = NULL;
  ENUMERATE (dim, index_it, indices.begin(), indices.end()) {
    SgExpression *idx = sb::buildVarRefExp(*index_it);
    SgExpression *test = sb::buildOrOp(
        sb::buildLessThanOp(idx,
                            sb::buildAddOp(BuildDomMinRef(dom_ref, dim),
                                           width)),
        sb::buildGreaterOrEqualOp(
            idx,
            sb::buildSubtractOp(BuildDomMaxRef(dom_ref, dim), width)));
    if (test_all) {
      test_all = sb::buildOrOp(test_all, test);
    } else {
      test_all = test;
    }
  }
  SgIfStmt *ifstmt = sb::buildIfStmt(test_all, ifclause, NULL);
  return ifstmt;
}

// REFACTORING
void MPICUDATranslator::ProcessStencilMap(
    StencilMap *smap,
    SgVarRefExp *stencils,
    int stencil_map_index,
    Run *run,
    SgScopeStatement *function_body,
    SgScopeStatement *loop_body,
    SgVariableDeclaration *block_dim) {
  string stencil_name = "s" + toString(stencil_map_index);
  SgExpression *idx = sb::buildIntVal(stencil_map_index);
  SgType *stencil_ptr_type = sb::buildPointerType(smap->stencil_type());
  SgAssignInitializer *init =
      sb::buildAssignInitializer(
          sb::buildCastExp(
              sb::buildPntrArrRefExp(stencils, idx),
              stencil_ptr_type), stencil_ptr_type);
  SgVariableDeclaration *sdecl
      = sb::buildVariableDeclaration(stencil_name, stencil_ptr_type,
                                     init, function_body);
  SgVarRefExp *stencil_var = sb::buildVarRefExp(sdecl);
  function_body->append_statement(sdecl);

  SgInitializedNamePtrList remote_grids;
  SgStatementPtrList load_statements;
  bool overlap_eligible;
  int overlap_width;
  GenerateLoadRemoteGridRegion(smap, stencil_var, run, loop_body,
                               remote_grids, load_statements,
                               overlap_eligible, overlap_width);
  bool overlap_enabled = flag_mpi_overlap_ &&  overlap_eligible;
  if (overlap_enabled) {
    LOG_INFO() << "Generating overlapping code\n";
  } else {
    LOG_INFO() << "Generating non-overlapping code\n";    
  }
  // run kernel function
  SgFunctionSymbol *fs = rose_util::getFunctionSymbol(smap->run());
  PSAssert(fs);
  if (cache_config_done_.find(fs) == cache_config_done_.end()) {
    SgFunctionCallExp *cache_config =
        sbx::buildCudaCallFuncSetCacheConfig(fs,
                                             sbx::cudaFuncCachePreferL1);
    function_body->append_statement(sb::buildExprStatement(cache_config));
    cache_config_done_.insert(fs);
    if (overlap_enabled) {
      if (flag_multistream_boundary_) {
        for (int i = 0; i < smap->getNumDim(); ++i) {
          for (int j = 0; j < 2; ++j) {
            SgFunctionSymbol *fs_boundary =
                si::lookupFunctionSymbolInParentScopes(
                    smap->getRunName() + GetBoundarySuffix(i, j));
            PSAssert(fs_boundary);
            function_body->append_statement(
                sb::buildExprStatement(
                    sbx::buildCudaCallFuncSetCacheConfig(
                        fs_boundary, sbx::cudaFuncCachePreferL1)));
          }
        }
      } else {
        SgFunctionSymbol *fs_boundary =
            si::lookupFunctionSymbolInParentScopes(
                smap->getRunName() + GetBoundarySuffix());
        PSAssert(fs_boundary);
        function_body->append_statement(
            sb::buildExprStatement(
                sbx::buildCudaCallFuncSetCacheConfig(
                    fs_boundary, sbx::cudaFuncCachePreferL1)));
      }
      
      SgFunctionSymbol *fs_inner =
          rose_util::getFunctionSymbol(smap->run_inner());
      PSAssert(fs_inner);
      function_body->append_statement(
          sb::buildExprStatement(
              sbx::buildCudaCallFuncSetCacheConfig(
                  fs_inner, sbx::cudaFuncCachePreferL1)));
    
    }
  }
  
  // Call the stencil kernel
  // Build an argument list by expanding members of the parameter struct
  // i.e. struct {a, b, c}; -> (s.a, s.b, s.c)
  SgExprListExp *args = sb::buildExprListExp();
  SgExprListExp *args_boundary = sb::buildExprListExp();  
  SgClassDefinition *stencil_def = smap->GetStencilTypeDefinition();
  PSAssert(stencil_def);

  SgVariableDeclaration *grid_dim = cuda_trans_->BuildGridDimDeclaration(
      stencil_name + "_grid_dim",
      BuildGetLocalSize(sb::buildIntVal(0)),
      BuildGetLocalSize(sb::buildIntVal(1)),
      cuda_trans_->BuildBlockDimX(), cuda_trans_->BuildBlockDimY(),
      function_body);

  function_body->append_statement(grid_dim);
  
  // Append the local offset
  for (int i = 0; i < smap->getNumDim()-1; ++i) {
    args->append_expression(BuildGetLocalOffset(sb::buildIntVal(i)));
    if (!flag_multistream_boundary_)
      args_boundary->append_expression(BuildGetLocalOffset(
          sb::buildIntVal(i)));    
  }
  if (!flag_multistream_boundary_)
    args_boundary->append_expression(sb::buildIntVal(overlap_width));

  // Enumerate members of parameter struct
  const SgDeclarationStatementPtrList &members = stencil_def->get_members();
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    SgExpression *arg =
        sb::buildArrowExp(stencil_var, sb::buildVarRefExp(member_decl));
    //const SgInitializedNamePtrList &vars = member_decl->get_variables();
    //GridType *gt = tx_->findGridType(vars[0]->get_type());
    SgType *member_type = si::getFirstVarType(member_decl);
    GridType *gt = tx_->findGridType(member_type);
    if (gt) {
      arg = sb::buildPointerDerefExp(
          sb::buildCastExp(
              BuildGridGetDev(arg),
              sb::buildPointerType(cuda_trans_->BuildOnDeviceGridType(gt))));
      // skip the grid index
      ++member;
    }
    if (overlap_enabled && Domain::isDomainType(member_type)) {
      args->append_expression(BuildDomainShrink(
          sb::buildAddressOfOp(arg), sb::buildIntVal(overlap_width)));
    } else {
      args->append_expression(arg);
    }
    args_boundary->append_expression(arg);    
  }

  // Generate Kernel invocation code
  SgCudaKernelExecConfig *cuda_config =
      sbx::buildCudaKernelExecConfig(sb::buildVarRefExp(grid_dim),
                                     sb::buildVarRefExp(block_dim),
                                     NULL, NULL);
  if (overlap_enabled) {
    SgVarRefExp *inner_stream = sb::buildVarRefExp("stream_inner");
    PSAssert(inner_stream);
    SgCudaKernelExecConfig *cuda_config_inner =
      sbx::buildCudaKernelExecConfig(sb::buildVarRefExp(grid_dim),
                                     sb::buildVarRefExp(block_dim),
                                     NULL, inner_stream);

    SgFunctionSymbol *fs_inner =
        rose_util::getFunctionSymbol(smap->run_inner());
    SgCudaKernelCallExp *c =
        sbx::buildCudaKernelCallExp(sb::buildFunctionRefExp(fs_inner),
                                    args, cuda_config_inner);
    loop_body->append_statement(sb::buildExprStatement(c));
    // perform boundary exchange concurrently
    FOREACH (sit, load_statements.begin(), load_statements.end()) {
      loop_body->append_statement(*sit);
    }
    LOG_INFO() << "generating call to boundary kernel\n";
    if (overlap_width && !flag_multistream_boundary_) {
      LOG_INFO() << "single-stream version\n";
      SgFunctionSymbol *fs_boundary =
          si::lookupFunctionSymbolInParentScopes(
              smap->getRunName() + GetBoundarySuffix());
      c = sbx::buildCudaKernelCallExp(sb::buildFunctionRefExp(fs_boundary),
                                      args_boundary, cuda_config);
      loop_body->append_statement(sb::buildExprStatement(c));
    } else if (overlap_width) {
      LOG_INFO() << "multi-stream version\n";
      // rose_util::AppendExprStatement(
      //     loop_body,
      //     BuildCudaStreamSynchronize(sb::buildVarRefExp("stream_boundary_copy")));
      SgExpressionPtrList &arg_list = args_boundary->get_expressions();
      SgExpression *dom = arg_list.front();      
      arg_list.erase(arg_list.begin());      
      // 6 streams for
      int stream_index = 0;
      int num_x_streams = 5;
      for (int j = 0; j < 2; ++j) {
        for (int i = 0; i < num_x_streams; ++i) {
          SgExpression *bd =
              BuildDomainGetBoundary(sb::buildAddressOfOp(dom),
                                     0, j, sb::buildIntVal(overlap_width),
                                     num_x_streams, i);
          args_boundary = sb::buildExprListExp(arg_list);
          args_boundary->prepend_expression(bd);
          int dimz = 512 / (overlap_width * 128);
          SgCudaKernelExecConfig *boundary_config =
              sbx::buildCudaKernelExecConfig(
                  sb::buildIntVal(1),
                  BuildCudaDim3(sb::buildIntVal(overlap_width),
                                sb::buildIntVal(128),
                                sb::buildIntVal(dimz)),
                  NULL, BuildStreamBoundaryKernel(stream_index));
          ++stream_index;
          SgFunctionSymbol *fs_boundary
              = si::lookupFunctionSymbolInParentScopes(
                  smap->getRunName() + GetBoundarySuffix(0, j));
          c = sbx::buildCudaKernelCallExp(
              sb::buildFunctionRefExp(fs_boundary),
              args_boundary, boundary_config);
          loop_body->append_statement(sb::buildExprStatement(c));
        }
      }
      for (int j = 1; j < 3; ++j) {
        for (int i = 0; i < 2; ++i) {
          SgExpression *bd =
              BuildDomainGetBoundary(sb::buildAddressOfOp(dom),
                                     j, i, sb::buildIntVal(overlap_width),
                                     1, 0);
          args_boundary = sb::buildExprListExp(arg_list);
          args_boundary->prepend_expression(bd);
          SgCudaKernelExecConfig *boundary_config;
          if (j == 1) {
            int dimz = 512 / (overlap_width * 128);
            boundary_config = sbx::buildCudaKernelExecConfig(
                sb::buildIntVal(1),
                BuildCudaDim3(sb::buildIntVal(128),
                              sb::buildIntVal(overlap_width),
                              sb::buildIntVal(dimz)),
                NULL, BuildStreamBoundaryKernel(stream_index));
          } else {
            boundary_config = sbx::buildCudaKernelExecConfig(
                sb::buildIntVal(1),
                BuildCudaDim3(sb::buildIntVal(128),
                              sb::buildIntVal(4)),
                NULL, BuildStreamBoundaryKernel(stream_index));
          }
          ++stream_index;
          SgFunctionSymbol *fs_boundary
              = si::lookupFunctionSymbolInParentScopes(
                  smap->getRunName() + GetBoundarySuffix(j, i));
          c = sbx::buildCudaKernelCallExp(sb::buildFunctionRefExp(fs_boundary),
                                          args_boundary, boundary_config);
          loop_body->append_statement(sb::buildExprStatement(c));
        }
      }
      loop_body->append_statement(sb::buildExprStatement(
          BuildCudaThreadSynchronize()));
    }
  } else {
    // perform boundary exchange before kernel invocation synchronously
    FOREACH (sit, load_statements.begin(), load_statements.end()) {
      loop_body->append_statement(*sit);
    }
    SgCudaKernelCallExp *c =
        sbx::buildCudaKernelCallExp(sb::buildFunctionRefExp(fs),
                                    args, cuda_config);
    loop_body->append_statement(sb::buildExprStatement(c));
  }
  appendGridSwap(smap, stencil_var, loop_body);
  DeactivateRemoteGrids(smap, stencil_var, loop_body,
                        remote_grids);

  FixGridAddresses(smap, stencil_var, function_body);
}

SgBasicBlock *MPICUDATranslator::BuildRunBody(Run *run) {
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));

  string stencil_param_name = "stencils";
  SgVarRefExp *stencils = sb::buildVarRefExp(stencil_param_name,
                                             block);

  SgVariableDeclaration *block_dim =
      sbx::buildDim3Declaration("block_dim",
                                cuda_trans_->BuildBlockDimX(),
                                cuda_trans_->BuildBlockDimY(),
                                cuda_trans_->BuildBlockDimZ(),
                                block);
  block->append_statement(block_dim);
  
  // build main loop
  SgBasicBlock *loopBody = sb::buildBasicBlock();
  cache_config_done_.clear();
  ENUMERATE(i, it, run->stencils().begin(), run->stencils().end()) {
    ProcessStencilMap(it->second, stencils, i, run,
                      block, loopBody, block_dim);
  }
  SgVariableDeclaration *lv
      = sb::buildVariableDeclaration("i", sb::buildIntType(), NULL, block);
  block->append_statement(lv);
  SgStatement *loopTest =
      sb::buildExprStatement(
          sb::buildLessThanOp(sb::buildVarRefExp(lv),
                              sb::buildVarRefExp("iter", block)));
  SgForStatement *loop =
      sb::buildForStatement(sb::buildAssignStatement(sb::buildVarRefExp(lv),
                                                     sb::buildIntVal(0)),
                            loopTest,
                            sb::buildPlusPlusOp(sb::buildVarRefExp(lv)),
                            loopBody);

  //block->append_statement(loop);  
  TraceStencilRun(run, loop, block);
  // cudaThreadSynchronize after each loop
  block->insert_statement(
      loop, sb::buildExprStatement(BuildCudaThreadSynchronize()), false);
  
  return block;
}

static std::string GetTypeDimSig(const std::string &s) {
  for (int i = 1; i <= PS_MAX_DIM; ++i) {
    vector<string> names;
    names.push_back("Float");
    names.push_back("Double");
    FOREACH (it, names.begin(), names.end()) {
      string key = (*it) + toString(i) + "D";
      if (s.find(key) != string::npos) return key;
    }
  }
  return "";
}

SgFunctionDeclaration *
MPICUDATranslator::BuildInteriorKernel(SgFunctionDeclaration *original)
    const {
  SgFunctionDeclaration *inner_version =
      rose_util::CloneFunction(original,
                               original->get_name() + inner_prefix_);
  PSAssert(inner_version);
  Rose_STL_Container<SgNode*> calls =
      NodeQuery::querySubTree(inner_version, V_SgFunctionCallExp);

  FOREACH (it, calls.begin(), calls.end()) {
    SgFunctionCallExp *fc = isSgFunctionCallExp(*it);
    PSAssert(fc);
    SgFunctionDeclaration *decl = fc->getAssociatedFunctionDeclaration();
    PSAssert(decl);
    SgFunctionSymbol *sym = fc->getAssociatedFunctionSymbol();
    PSAssert(sym);
    string name = sym->get_name();
    if (startswith(name, get_addr_name_)) {
      if (startswith(name, get_addr_no_halo_name_)) continue;
      //replace getaddr with getaddrnohalo
      string key = GetTypeDimSig(name);
      PSAssert(key != "");
      name = get_addr_no_halo_name_ + key;
      LOG_INFO() << "Redirecting to " << name << "\n";
      fc->set_function(sb::buildFunctionRefExp(name));
      continue;
    }
    // No redirection for emits
    if (startswith(name, emit_addr_name_)) continue;
    // Redirect intra-kernel calls 
    if (decl->get_definingDeclaration()) {
      fc->set_function(sb::buildFunctionRefExp(name + inner_prefix_));
      continue;
    }
  }
  if (cuda_trans_->flag_pre_calc_grid_address()) {
    MPICUDAOptimizer opt(*this);
    opt.GridPreCalcAddr(inner_version);
  }
  return inner_version;
}

static int GetMaximumNumberOfDimensions(SgFunctionDeclaration *func) {
  // TODO: This does not work for intra kernels
  // Possible fix: find the Kernel object, and get the parent
  // func Find The root kernel func, and then use the below logic to
  // get the number of possible max dim.
  SgFunctionParameterList *params = func->get_parameterList();
  SgInitializedNamePtrList &param_args = params->get_args();
  int dim = 0;
  ENUMERATE (i, it, param_args.begin(), param_args.end()) {
    SgInitializedName *p = *it;
    if (!rose_util::IsIntLikeType(p)) {
      dim = i;
      break;
    }
  }
  LOG_DEBUG() << "Kernel (" << string(func->get_name()) << ") max dim: "
              << dim << "\n";
  return dim;
  
}

// Generates per-boundary kernels. 
std::vector<SgFunctionDeclaration*>
MPICUDATranslator::BuildBoundaryKernel(SgFunctionDeclaration *original) {
  std::vector<SgFunctionDeclaration*> bkernels;
  int ndim = GetMaximumNumberOfDimensions(original);
  for (int i = 0; i < ndim; ++i) {
    for (int j = 0; j < 2; ++j) {
      string suffix = GetBoundarySuffix(i, j);
      LOG_INFO() << "Generating device function: "
                  << string(original->get_name() + suffix) << "\n";
      SgFunctionDeclaration *boundary_version =
          rose_util::CloneFunction(original,
                                   original->get_name() + suffix,
                                   global_scope_);
      PSAssert(boundary_version);
      bkernels.push_back(boundary_version);
      Rose_STL_Container<SgNode*> calls =
          NodeQuery::querySubTree(boundary_version, V_SgFunctionCallExp);

      FOREACH (it, calls.begin(), calls.end()) {
        SgFunctionCallExp *fc = isSgFunctionCallExp(*it);
        PSAssert(fc);
        SgFunctionDeclaration *decl = fc->getAssociatedFunctionDeclaration();
        PSAssert(decl);
        SgFunctionSymbol *sym = fc->getAssociatedFunctionSymbol();
        PSAssert(sym);
        string name = sym->get_name();
        if (startswith(name, get_addr_name_)) {
          if (startswith(name, get_addr_no_halo_name_)) continue;
          if (!fc->attributeExists(StencilIndexAttribute::name)) continue;
          const StencilIndexList &sil =
              static_cast<StencilIndexAttribute*>(fc->getAttribute("StencilIndexList"))->stencil_index_list();

          LOG_DEBUG() << "sil: " << sil << "\n";
          // TODO: the kernel might be used for smaller dimension
          // grids, but that kernel is not recognized as regular even
          // if it's really the case because ndim is used as num_dim param.
          if (!StencilIndexRegularOrder(sil, ndim)) continue;
          int offset = sil[i].offset;
          StencilIndexList t = sil;
          t[i].offset = 0;
          if (!StencilIndexSelf(t, ndim)) continue;
          if ((j == 0 && offset < 0) || ((j == 1) && offset > 0)) {
            continue;
          }
          string key = GetTypeDimSig(name);
          PSAssert(key != "");
          name = get_addr_no_halo_name_ + key;
          LOG_INFO() << "Redirecting to " << name << "\n";
          fc->set_function(sb::buildFunctionRefExp(name));
          continue;
        }
        // No redirection for emits
        if (startswith(name, emit_addr_name_)) continue;
        // Redirect intra-kernel calls
        if (decl->get_definingDeclaration()) {
          fc->set_function(sb::buildFunctionRefExp(name + suffix));
          continue;
        }
      }
    }
  }
  return bkernels;
}


void MPICUDATranslator::translateKernelDeclaration(
    SgFunctionDeclaration *node) {
  LOG_DEBUG() << "Translating to CUDA kernel\n";
  node->get_functionModifier().setCudaDevice();

  // e.g., PSGrid3DFloat -> __PSGrid3DFloatDev *
  Rose_STL_Container<SgNode*> exps =
      NodeQuery::querySubTree(node, V_SgInitializedName);
  FOREACH (it, exps.begin(), exps.end()) {
    SgInitializedName *exp = isSgInitializedName(*it);
    PSAssert(exp);
    SgType *cur_type = exp->get_type();
    GridType *gt = tx_->findGridType(cur_type);
    // not a grid type
    if (!gt) continue;
    SgType *new_type = sb::buildPointerType(
        cuda_trans_->BuildOnDeviceGridType(gt));
    exp->set_type(new_type);
  }
  
  Rose_STL_Container<SgNode*> gdim_calls =
      NodeQuery::querySubTree(node, V_SgFunctionCallExp);
  SgFunctionSymbol *gdim_dev =
      si::lookupFunctionSymbolInParentScopes("__PSGridDimDev");
  FOREACH (it, gdim_calls.begin(), gdim_calls.end()) {
    SgFunctionCallExp *fc = isSgFunctionCallExp(*it);
    PSAssert(fc);
    if (fc->getAssociatedFunctionSymbol() != grid_dim_get_func_)
      continue;
    fc->set_function(sb::buildFunctionRefExp(gdim_dev));
  }

  if (flag_mpi_overlap_)
    si::insertStatementBefore(node, BuildInteriorKernel(node), false);

  if (flag_multistream_boundary_) {
    std::vector<SgFunctionDeclaration*> boundary_kernels
        = BuildBoundaryKernel(node);
    FOREACH (it, boundary_kernels.begin(), boundary_kernels.end()) {
      si::insertStatementBefore(node, *it, false);
    }
  }
  return;
}

// This is almost equivalent as CUDATranslator::BuildRunKernel, except
// for having offset.
SgFunctionDeclaration *MPICUDATranslator::BuildRunKernel(
    StencilMap *stencil) {
  SgFunctionParameterList *params = sb::buildFunctionParameterList();
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);
  SgInitializedName *dom_arg = NULL;
  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();
  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    params->append_arg(sb::buildInitializedName("offset" + toString(i),
                                                sb::buildIntType()));
  }
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = sb::buildInitializedName(
        vars[0]->get_name(), vars[0]->get_type());
    SgType *type = arg->get_type();
    LOG_DEBUG() << "type: " << type->unparseToString() << "\n";
    if (Domain::isDomainType(type)) {
      if (!dom_arg) { dom_arg = arg; }
    } else if (GridType::isGridType(type)) {
      SgType *gt = cuda_trans_->BuildOnDeviceGridType(
          tx_->findGridType(type));
      arg->set_type(gt);
      // skip the grid index
      ++member;
    }
    params->append_arg(arg);
  }
  PSAssert(dom_arg);

  LOG_INFO() << "Declaring and defining function named "
             << stencil->getRunName() << "\n";
  SgFunctionDeclaration *run_func =
      sb::buildDefiningFunctionDeclaration(stencil->getRunName(),
                                           sb::buildVoidType(),
                                           params, global_scope_);
  
  si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
  run_func->get_functionModifier().setCudaKernel();
  SgBasicBlock *func_body = BuildRunKernelBody(stencil, dom_arg);
  si::appendStatement(func_body, run_func->get_definition());
  rose_util::AddASTAttribute(run_func, new RunKernelAttribute());
  return run_func;
}

SgFunctionDeclaration *MPICUDATranslator::BuildRunInteriorKernel(
    StencilMap *stencil) {

  if (!flag_mpi_overlap_) return NULL;
  
  SgFunctionParameterList *params = sb::buildFunctionParameterList();
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  SgInitializedName *dom_arg = NULL;

  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();
  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    params->append_arg(sb::buildInitializedName("offset" + toString(i),
                                                sb::buildIntType()));
  }
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = sb::buildInitializedName(
        vars[0]->get_name(), vars[0]->get_type());
    SgType *type = arg->get_type();
    LOG_DEBUG() << "type: " << type->unparseToString() << "\n";
    if (Domain::isDomainType(type)) {
      if (!dom_arg) { dom_arg = arg; }
    } else if (GridType::isGridType(type)) {
      SgType *gt = cuda_trans_->BuildOnDeviceGridType(
          tx_->findGridType(type));
      arg->set_type(gt);
      // skip the grid index
      ++member;
    }
    params->append_arg(sb::buildInitializedName(arg->get_name(),
                                                arg->get_type()));
  }
  PSAssert(dom_arg);

  string func_name = stencil->getRunName() + inner_prefix_;
  LOG_INFO() << "Declaring and defining function named "
             << func_name << "\n";
  SgFunctionDeclaration *run_func =
      sb::buildDefiningFunctionDeclaration(func_name,
                                           sb::buildVoidType(),
                                           params, global_scope_);
  
  si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
  run_func->get_functionModifier().setCudaKernel();
  SgBasicBlock *func_body = BuildRunInteriorKernelBody(stencil, dom_arg);
  si::appendStatement(func_body, run_func->get_definition());

  return run_func;
}

void MPICUDATranslator::BuildFunctionParamList(
    SgClassDefinition *param_struct_def,
    SgFunctionParameterList *&params,
    SgInitializedName *&grid_arg,
    SgInitializedName *&dom_arg) {
  LOG_DEBUG() << "Building function parameter list\n";
  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();

  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = sb::buildInitializedName(
        vars[0]->get_name(), vars[0]->get_type());
    SgType *type = arg->get_type();
    if (Domain::isDomainType(type)) {
      if (!dom_arg) {
        dom_arg =  sb::buildInitializedName(arg->get_name(),
                                            arg->get_type());
      }
    } else if (GridType::isGridType(type)) {
      SgType *gt = cuda_trans_->BuildOnDeviceGridType(
          tx_->findGridType(type));
      arg->set_type(gt);
      if (!grid_arg) {
        grid_arg = sb::buildInitializedName(arg->get_name(),
                                            arg->get_type());
      }
      // skip the grid index
      ++member;
    }
    params->append_arg(sb::buildInitializedName(arg->get_name(),
                                                arg->get_type()));
  }
  return;
}

SgFunctionDeclarationPtrVector
MPICUDATranslator::BuildRunMultiStreamBoundaryKernel(
    StencilMap *stencil) {
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  std::vector<SgFunctionDeclaration*> run_funcs;

  for (int i = 0; i < stencil->getNumDim(); ++i) {
    for (int j = 0; j < 2; ++j) {
      bool fw = j;
      string name = stencil->getRunName() + GetBoundarySuffix(i, fw);
      LOG_INFO() << "Generating global function: " << name << "\n";
      SgFunctionParameterList *params = sb::buildFunctionParameterList();
      SgInitializedName *grid_arg = NULL;
      SgInitializedName *dom_arg = NULL;
      BuildFunctionParamList(param_struct_def, params,
                             grid_arg, dom_arg);
      PSAssert(dom_arg);
      SgFunctionDeclaration *run_func =
          sb::buildDefiningFunctionDeclaration(
              name, sb::buildVoidType(),
              params, global_scope_);
      si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
      run_func->get_functionModifier().setCudaKernel();
      SgBasicBlock *func_body = BuildRunMultiStreamBoundaryKernelBody(
          stencil, grid_arg, dom_arg, i, j);
      si::appendStatement(func_body, run_func->get_definition());
      run_funcs.push_back(run_func);
    }
  }
  return run_funcs;
}

SgFunctionDeclarationPtrVector
MPICUDATranslator::BuildRunBoundaryKernel(StencilMap *stencil) {
  std::vector<SgFunctionDeclaration*> run_funcs;
  if (!flag_mpi_overlap_) return run_funcs;;
  if (flag_multistream_boundary_)
    return BuildRunMultiStreamBoundaryKernel(stencil);

  SgFunctionParameterList *params = sb::buildFunctionParameterList();
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  SgInitializedName *grid_arg = NULL;
  SgInitializedName *dom_arg = NULL;

  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();

  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    params->append_arg(sb::buildInitializedName("offset" + toString(i),
                                                sb::buildIntType()));
  }

  params->append_arg(sb::buildInitializedName(boundary_kernel_width_name_,
                                              sb::buildIntType()));
  
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = sb::buildInitializedName(
        vars[0]->get_name(), vars[0]->get_type());
    SgType *type = arg->get_type();
    LOG_DEBUG() << "type: " << type->unparseToString() << "\n";
    if (Domain::isDomainType(type)) {
      if (!dom_arg) {
        dom_arg = arg;
      }
    } else if (GridType::isGridType(type)) {
      SgType *gt = cuda_trans_->BuildOnDeviceGridType(
          tx_->findGridType(type));
      arg->set_type(gt);
      if (!grid_arg) { grid_arg = arg;  }
      // skip the grid index
      ++member;
    }
    params->append_arg(arg);
  }
  PSAssert(grid_arg);
  PSAssert(dom_arg);

  LOG_INFO() << "Declaring and defining function named "
             << stencil->getRunName() << "\n";
  SgFunctionDeclaration *run_func =
      sb::buildDefiningFunctionDeclaration(stencil->getRunName()
                                           + boundary_suffix_,
                                           sb::buildVoidType(),
                                           params, global_scope_);
  
  si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
  run_func->get_functionModifier().setCudaKernel();
  SgBasicBlock *func_body = BuildRunBoundaryKernelBody(
      stencil, dom_arg);
  si::appendStatement(func_body, run_func->get_definition());
  run_funcs.push_back(run_func);
  return run_funcs;
}

SgBasicBlock* MPICUDATranslator::BuildRunMultiStreamBoundaryKernelBody(
    StencilMap *stencil,
    SgInitializedName *grid_arg,
    SgInitializedName *dom_arg, int dim, bool fw) {
  LOG_DEBUG() << "Generating run boundary kernel body\n";
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  SgExpression *domain = sb::buildVarRefExp(dom_arg);
  SgExpression *min_field = BuildDomMinRef(domain);
  SgExpression *max_field = BuildDomMaxRef(domain);
  
  SgExpressionPtrList index_args;
  PSAssert(stencil->getNumDim() == 3);

  SgVariableDeclaration *x_index = sb::buildVariableDeclaration
      ("x", sb::buildIntType(), NULL, block);
  SgVariableDeclaration *y_index = sb::buildVariableDeclaration
      ("y", sb::buildIntType(), NULL, block);
  SgVariableDeclaration *z_index = sb::buildVariableDeclaration
      ("z", sb::buildIntType(), NULL, block);

  block->append_statement(x_index);    
  block->append_statement(y_index);
  block->append_statement(z_index);

  index_args.push_back(sb::buildVarRefExp(x_index));
  index_args.push_back(sb::buildVarRefExp(y_index));
  index_args.push_back(sb::buildVarRefExp(z_index));  

  SgVariableDeclaration *loop_index = x_index;
  SgStatement *loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),
      sb::buildAddOp(sbx::buildCudaIdxExp(sbx::kThreadIdxX),
                     sb::buildPntrArrRefExp(min_field,
                                            sb::buildIntVal(0))));
  SgStatement *loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildPntrArrRefExp(max_field,
                                                 sb::buildIntVal(0))));
  SgExpression *loop_incr =
      sb::buildPlusAssignOp(sb::buildVarRefExp(loop_index),
                            sbx::buildCudaIdxExp(sbx::kBlockDimX));

  SgBasicBlock *loop_body = sb::buildBasicBlock();
  SgExprListExp *kernel_args=
      cuda_trans_->BuildKernelCallArgList(stencil, index_args);
  string kernel_name = stencil->getKernel()->get_name()
      + GetBoundarySuffix(dim, fw);
  SgFunctionDeclaration *kernel =
      sb::buildNondefiningFunctionDeclaration(
          kernel_name,
          stencil->getKernel()->get_type()->get_return_type(),
          stencil->getKernel()->get_parameterList(),
          global_scope_);
  SgFunctionCallExp *kernel_call =
      sb::buildFunctionCallExp(sb::buildFunctionRefExp(kernel), kernel_args);
  loop_body->append_statement(sb::buildExprStatement(kernel_call));

  SgStatement *loop
      = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);

  // Creates doubly nested loops with y and z dimensions
  for (int i = 1; i <= 2; i++) {
    SgExpression *threadIdx = NULL;
    SgExpression *blockDim = NULL;
    if (i == 1) {
      loop_index = y_index;
      threadIdx = sbx::buildCudaIdxExp(sbx::kThreadIdxY);
      blockDim = sbx::buildCudaIdxExp(sbx::kBlockDimY);
    } else if (i == 2) {
      loop_index = z_index;
      threadIdx = sbx::buildCudaIdxExp(sbx::kThreadIdxZ);
      blockDim = sbx::buildCudaIdxExp(sbx::kBlockDimZ);
    }
    loop_init = sb::buildAssignStatement(
        sb::buildVarRefExp(loop_index),
        sb::buildAddOp(threadIdx,
                       sb::buildPntrArrRefExp(min_field,
                                              sb::buildIntVal(i))));
    loop_test = sb::buildExprStatement(
        sb::buildLessThanOp(
            sb::buildVarRefExp(loop_index),
            sb::buildPntrArrRefExp(max_field, sb::buildIntVal(i))));
    loop_incr = sb::buildPlusAssignOp(
        sb::buildVarRefExp(loop_index), blockDim);
    loop = sb::buildForStatement(loop_init, loop_test, loop_incr, loop);
  }
  block->append_statement(loop);

  return block;
}

bool MPICUDATranslator::translateGetKernel(SgFunctionCallExp *node,
                                           SgInitializedName *gv) {
  // 
  // *((gt->getElmType())__PSGridGetAddressND(g, x, y, z))

  GridType *gt = tx_->findGridType(gv->get_type());
  int nd = gt->getNumDim();
  SgScopeStatement *scope = getContainingScopeStatement(node);  
  SgVarRefExp *g = sb::buildVarRefExp(gv->get_name(), scope);
  
  string get_address_name = get_addr_name_ +  GetTypeDimName(gt);
  string get_address_no_halo_name = get_addr_no_halo_name_ +  GetTypeDimName(gt);
  SgFunctionRefExp *get_address = NULL;
  const StencilIndexList *sil = tx_->findStencilIndex(node);
  PSAssert(sil);
  LOG_DEBUG() << "Stencil index: " << *sil << "\n";
  if (StencilIndexSelf(*sil, nd)) {
    get_address = sb::buildFunctionRefExp(get_address_no_halo_name,
                                          global_scope_);
  } else if (StencilIndexRegularOrder(*sil, nd)) {
    for (int i = 0; i < nd; ++i) {
      int offset = (*sil)[i].offset;
      if (!offset) continue;
      string method_name = 
          get_address_name + "_" +
          toString(i) + "_" + ((offset < 0) ? "bw" : "fw");
      LOG_INFO() << "Using " << method_name << "\n";
      get_address = sb::buildFunctionRefExp(method_name, global_scope_);
      break;
    }
  } else {
    get_address = sb::buildFunctionRefExp(get_address_name,
                                          global_scope_);
  }
  SgExprListExp *args = sb::buildExprListExp(g);
  FOREACH (it, node->get_args()->get_expressions().begin(),
           node->get_args()->get_expressions().end()) {
    args->append_expression(si::copyExpression(*it));
  }

  SgFunctionCallExp *get_address_exp
      = sb::buildFunctionCallExp(get_address, args);
  // refactoring: merge the two attributes
  get_address_exp->setAttribute(StencilIndexAttribute::name,
                                new StencilIndexAttribute(*sil));
  get_address_exp->setAttribute(GridCallAttribute::name,
                                node->getAttribute(GridCallAttribute::name));
  SgExpression *x = sb::buildPointerDerefExp(get_address_exp);
  si::replaceExpression(node, x);
  return true;
}

} // namespace translator
} // namespace physis
