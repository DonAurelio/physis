// Copyright 2011, Tokyo Institute of Technology.
// All rights reserved.
//
// This file is distributed under the license described in
// LICENSE.txt.
//
// Author: Naoya Maruyama (naoya@matsulab.is.titech.ac.jp)

#include "translator/mpi_cuda_translator.h"

#include "translator/translation_context.h"
#include "translator/translation_util.h"
#include "translator/mpi_runtime_builder.h"
#include "translator/mpi_cuda_runtime_builder.h"
#include "translator/reference_runtime_builder.h"
#include "translator/cuda_runtime_builder.h"
#include "translator/SageBuilderEx.h"
#include "translator/cuda_builder.h"
#include "translator/rose_util.h"
#include "translator/runtime_builder.h"
#include "translator/mpi_cuda_optimizer.h"
#include "translator/rose_ast_attribute.h"

namespace pu = physis::util;
namespace sb = SageBuilder;
namespace si = SageInterface;
namespace sbx = physis::translator::SageBuilderEx;

namespace physis {
namespace translator {

std::string MPICUDATranslator::GetBoundarySuffix(int dim, bool fw) {
  return boundary_suffix_ + "_" +
      toString(dim+1) + "_" + (fw ? "fw" : "bw");
}

std::string MPICUDATranslator::GetBoundarySuffix() {
  return boundary_suffix_;
}

MPICUDATranslator::MPICUDATranslator(const Configuration &config)
    : MPITranslator(config),
      cuda_trans_(new CUDATranslator(config)),
      boundary_kernel_width_name_("halo_width"),
      inner_prefix_("_inner"),
      boundary_suffix_("_boundary") {  
  grid_create_name_ = "__PSGridNewMPI";
  target_specific_macro_ = "PHYSIS_MPI_CUDA";
  flag_multistream_boundary_ = false;
  const pu::LuaValue *lv =
      config.Lookup(Configuration::MULTISTREAM_BOUNDARY);
  if (lv) {
    PSAssert(lv->get(flag_multistream_boundary_));
  }
  if (flag_multistream_boundary_) {
    LOG_INFO() << "Multistream boundary enabled\n";
  }
  validate_ast_ = true;
}

MPICUDATranslator::~MPICUDATranslator() {
  delete cuda_trans_;
}

void MPICUDATranslator::SetUp(SgProject *project,
                              TranslationContext *context) {
  MPITranslator::SetUp(project, context);
  LOG_DEBUG() << "Parent setup done\n";
  cuda_trans_->SetUp(project, context);
  LOG_DEBUG() << "cuda_trans_ setup done\n";
}

void MPICUDATranslator::Finish() {
  cuda_trans_->Finish();
  MPITranslator::Finish();
}


// This is the same as CUDATranslator::BuildRunKernelBody, except for
// this version needs to add offsets to the x and y indices.
SgBasicBlock* MPICUDATranslator::BuildRunKernelBody(
    StencilMap *stencil,
    SgInitializedName *dom_arg) {
  LOG_DEBUG() << __FUNCTION__;
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  int dim = stencil->getNumDim();  
  SgExpression *min_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_min"));
  SgExpression *max_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_max"));
  vector<SgExpression*> offset_exprs;
  for (int i = 0; i < dim-1; ++i) {
    offset_exprs.push_back(sb::buildVarRefExp("offset" + toString(i)));
  }
  
  SgExpressionPtrList index_args;
  if (dim < 3) {
    LOG_ERROR() << "not supported yet.\n";
  } else if (dim == 3) {
    // x = blockIdx.x * blockDim.x + threadIdx.x + offset.x;
    SgAssignInitializer *x_init =
        sb::buildAssignInitializer(
            sb::buildAddOp(
                sb::buildAddOp(sb::buildMultiplyOp(
                    sbx::buildCudaIdxExp(sbx::kBlockIdxX),
                    sbx::buildCudaIdxExp(sbx::kBlockDimX)),
                               sbx::buildCudaIdxExp(sbx::kThreadIdxX)),
                offset_exprs[0]));
    // y = blockIdx.y * blockDim.y + threadIdx.y + offset.y;    
    SgAssignInitializer *y_init = 
        sb::buildAssignInitializer(
            sb::buildAddOp(
                sb::buildAddOp(sb::buildMultiplyOp(
                    sbx::buildCudaIdxExp(sbx::kBlockIdxY),
                    sbx::buildCudaIdxExp(sbx::kBlockDimY)),
                               sbx::buildCudaIdxExp(sbx::kThreadIdxY)),
                offset_exprs[1]));
        
    SgVariableDeclaration *x_index = sb::buildVariableDeclaration
        ("x", sb::buildIntType(), x_init, block);
    SgVariableDeclaration *y_index = sb::buildVariableDeclaration
        ("y", sb::buildIntType(), y_init, block);
    SgVariableDeclaration *z_index = sb::buildVariableDeclaration
        ("z", sb::buildIntType(), NULL, block);
    rose_util::AddASTAttribute<RunKernelIndexVarAttribute>(
        x_index, new RunKernelIndexVarAttribute(1));
    rose_util::AddASTAttribute<RunKernelIndexVarAttribute>(
        y_index, new RunKernelIndexVarAttribute(2));
    rose_util::AddASTAttribute<RunKernelIndexVarAttribute>(
        z_index, new RunKernelIndexVarAttribute(3));
    si::appendStatement(x_index, block);
    si::appendStatement(y_index, block);
    index_args.push_back(sb::buildVarRefExp(x_index));
    index_args.push_back(sb::buildVarRefExp(y_index));

    SgVariableDeclaration *loop_index = z_index;
    SgExpression *loop_begin =
        sb::buildPntrArrRefExp(min_field, sb::buildIntVal(2));
    SgStatement *loop_init = sb::buildAssignStatement(
        sb::buildVarRefExp(loop_index),
        loop_begin);
    SgExpression *loop_end =
        sb::buildPntrArrRefExp(max_field,
                               sb::buildIntVal(2));
    SgStatement *loop_test = sb::buildExprStatement(
        sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                            loop_end));
    index_args.push_back(sb::buildVarRefExp(loop_index));

    SgVariableDeclaration* t[] = {x_index, y_index};
    vector<SgVariableDeclaration*> range_checking_idx(t, t + 2);
    si::appendStatement(
        cuda_trans_->BuildDomainInclusionCheck(
            range_checking_idx, dom_arg),
        block);
    si::appendStatement(loop_index, block);

    SgExpression *loop_incr =
        sb::buildPlusPlusOp(sb::buildVarRefExp(loop_index));
    SgFunctionCallExp *kernel_call
        = cuda_trans_->BuildKernelCall(stencil, index_args);
    SgBasicBlock *loop_body =
        sb::buildBasicBlock(sb::buildExprStatement(kernel_call));
    SgStatement *loop
        = sb::buildForStatement(loop_init, loop_test,
                                loop_incr, loop_body);
    si::appendStatement(loop, block);
    rose_util::AddASTAttribute(
        loop,
        new RunKernelLoopAttribute(3, z_index->get_variables()[0],
                                   loop_begin, loop_end));
  }

  return block;
}

SgBasicBlock* MPICUDATranslator::BuildRunInteriorKernelBody(
    StencilMap *stencil, SgInitializedName *dom_arg) {
  LOG_DEBUG() << "Generating run stencil interior kernel body\n";  

  // Reuse BuildRunKernelBody function, and then redirect calls to
  // the inner kernel function
  
  SgBasicBlock *body = BuildRunKernelBody(stencil, dom_arg);
  const std::string &normal_kernel_name = stencil->getKernel()->get_name();
  const std::string &inner_kernel_name = normal_kernel_name 
                                         + inner_prefix_;
  LOG_DEBUG() << "normal kernel name: " << normal_kernel_name << "\n";
  LOG_DEBUG() << "inner kernel name: " << inner_kernel_name << "\n";
  SgFunctionDeclaration *inner_kernel =
      sb::buildNondefiningFunctionDeclaration(
          inner_kernel_name,
          stencil->getKernel()->get_type()->get_return_type(),
          isSgFunctionParameterList(
              si::copyStatement(stencil->getKernel()->get_parameterList())),
          global_scope_);
  
  rose_util::RedirectFunctionCalls
      (body, normal_kernel_name, inner_kernel);
  return body;
}

SgBasicBlock* MPICUDATranslator::BuildRunBoundaryKernelBody(
    StencilMap *stencil, SgInitializedName *dom_arg) {
  LOG_DEBUG() << "Generating run boundary kernel body\n";
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  int dim = stencil->getNumDim();  
  SgExpression *min_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_min"));
  SgExpression *max_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_max"));
  SgExpression *width = sb::buildVarRefExp(boundary_kernel_width_name_);
  vector<SgExpression*> offset_exprs;
  for (int i = 0; i < dim-1; ++i) {
    offset_exprs.push_back(sb::buildVarRefExp("offset" + toString(i)));
  }
  
  SgExpressionPtrList index_args;
  if (dim < 3) {
    LOG_ERROR() << "not supported yet.\n";
    PSAbort(1);
  }

  // int x = blockIdx.x * blockDim.x + threadIdx.x;
  SgVariableDeclaration *x_index = sb::buildVariableDeclaration(
      "x",
       sb::buildIntType(),
       sb::buildAssignInitializer(
           sb::buildAddOp(
               sb::buildAddOp(sb::buildMultiplyOp(
                   sbx::buildCudaIdxExp(sbx::kBlockIdxX),
                   sbx::buildCudaIdxExp(sbx::kBlockDimX)),
                              sbx::buildCudaIdxExp(sbx::kThreadIdxX)),
               offset_exprs[0])),
       block);
  
  // int y = blockIdx.y * blockDim.y + threadIdx.y;  
  SgVariableDeclaration *y_index = sb::buildVariableDeclaration(
      "y",
      sb::buildIntType(),
      sb::buildAssignInitializer(
          sb::buildAddOp(
              sb::buildAddOp(sb::buildMultiplyOp(
                  sbx::buildCudaIdxExp(sbx::kBlockIdxY),
                  sbx::buildCudaIdxExp(sbx::kBlockDimY)),
                             sbx::buildCudaIdxExp(sbx::kThreadIdxY)),
              offset_exprs[1])),
      block);
  
  SgVariableDeclaration *z_index = sb::buildVariableDeclaration
      ("z", sb::buildIntType(), NULL, block);

  si::appendStatement(x_index, block);
  si::appendStatement(y_index, block);

  index_args.push_back(sb::buildVarRefExp(x_index));
  index_args.push_back(sb::buildVarRefExp(y_index));

  SgExpression *dom_min_z = sb::buildPntrArrRefExp(min_field,
                                                   sb::buildIntVal(2));
  SgExpression *dom_max_z = sb::buildPntrArrRefExp(max_field,
                                                   sb::buildIntVal(2));
  
  SgVariableDeclaration *loop_index = z_index;      
  SgStatement *loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),
      si::copyExpression(dom_min_z));
  SgStatement *loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildAddOp(si::copyExpression(dom_min_z),
                                         si::copyExpression(width))));
  
  index_args.push_back(sb::buildVarRefExp(loop_index));

  SgVariableDeclaration* t[] = {x_index, y_index};
  vector<SgVariableDeclaration*> range_checking_idx(t, t + 2);

  si::appendStatement(
      cuda_trans_->BuildDomainInclusionCheck(
          range_checking_idx, dom_arg),
      block);
  si::appendStatement(loop_index, block);

  SgExpression *loop_incr =
      sb::buildPlusPlusOp(sb::buildVarRefExp(loop_index));
  SgFunctionCallExp *kernel_call
      = cuda_trans_->BuildKernelCall(stencil, index_args);
  SgBasicBlock *loop_body = sb::buildBasicBlock(
      sb::buildExprStatement(kernel_call));
  SgStatement *loop
      = sb::buildForStatement(
          loop_init, loop_test, loop_incr, loop_body);
  si::appendStatement(loop, block);

  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),
      sb::buildAddOp(si::copyExpression(dom_min_z),
                     si::copyExpression(width)));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildSubtractOp(
                              si::copyExpression(dom_max_z),
                              si::copyExpression(width))));
  loop = sb::buildForStatement(loop_init, loop_test,
                               loop_incr, loop_body);
  si::appendStatement(BuildDomainInclusionInnerCheck(
      range_checking_idx, dom_arg,
      si::copyExpression(width), loop), block);
  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),
      sb::buildSubtractOp(si::copyExpression(dom_max_z),
                          si::copyExpression(width)));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          si::copyExpression(dom_max_z)));
  loop = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);
  si::appendStatement(loop, block);
  si::deleteAST(dom_max_z);
  si::deleteAST(dom_min_z);
  si::deleteAST(width);
  return block;
}

SgIfStmt *MPICUDATranslator::BuildDomainInclusionInnerCheck(
    const vector<SgVariableDeclaration*> &indices,
    SgInitializedName *dom_arg, SgExpression *width,
    SgStatement *ifclause) const {
  SgExpression *test_all = NULL;
  ENUMERATE (dim, index_it, indices.begin(), indices.end()) {
    SgVariableDeclaration *idx = *index_it;    
    SgExpression *dom_min = sb::buildPntrArrRefExp(
        sb::buildDotExp(sb::buildVarRefExp(dom_arg),
                        sb::buildVarRefExp("local_min")),
        sb::buildIntVal(dim));
    SgExpression *dom_max = sb::buildPntrArrRefExp(
        sb::buildDotExp(sb::buildVarRefExp(dom_arg),
                        sb::buildVarRefExp("local_max")),
        sb::buildIntVal(dim));
    SgExpression *test = sb::buildOrOp(
        sb::buildLessThanOp(
            sb::buildVarRefExp(idx),
            sb::buildAddOp(dom_min,
                           si::copyExpression(width))),
        sb::buildGreaterOrEqualOp(
            sb::buildVarRefExp(idx),
            sb::buildSubtractOp(dom_max,
                                si::copyExpression(width))));
    if (test_all) {
      test_all = sb::buildOrOp(test_all, test);
    } else {
      test_all = test;
    }
  }
  SgIfStmt *ifstmt = sb::buildIfStmt(test_all, ifclause, NULL);
  si::deleteAST(width);
  return ifstmt;
}

// REFACTORING
void MPICUDATranslator::ProcessStencilMap(
    StencilMap *smap,
    SgVarRefExp *stencils,
    int stencil_map_index,
    Run *run,
    SgScopeStatement *function_body,
    SgScopeStatement *loop_body,
    SgVariableDeclaration *block_dim) {
  string stencil_name = "s" + toString(stencil_map_index);
  SgType *stencil_ptr_type = sb::buildPointerType(smap->stencil_type());
  SgAssignInitializer *init =
      sb::buildAssignInitializer(
          sb::buildCastExp(
              sb::buildPntrArrRefExp(stencils,
                                     sb::buildIntVal(stencil_map_index)),
              stencil_ptr_type), stencil_ptr_type);
  SgVariableDeclaration *sdecl
      = sb::buildVariableDeclaration(stencil_name, stencil_ptr_type,
                                     init, function_body);
  si::appendStatement(sdecl, function_body);

  SgInitializedNamePtrList remote_grids;
  SgStatementPtrList load_statements;
  bool overlap_eligible;
  int overlap_width;
  GenerateLoadRemoteGridRegion(smap, sdecl, run, loop_body,
                               remote_grids, load_statements,
                               overlap_eligible, overlap_width);
  bool overlap_enabled = flag_mpi_overlap_ &&  overlap_eligible;
  if (overlap_enabled) {
    LOG_INFO() << "Generating overlapping code\n";
  } else {
    LOG_INFO() << "Generating non-overlapping code\n";    
  }
  // run kernel function
  SgFunctionSymbol *fs = rose_util::getFunctionSymbol(smap->run());
  PSAssert(fs);

  // Refactoring: This block is for cache configuration.
  if (cache_config_done_.find(fs) == cache_config_done_.end()) {
    SgFunctionCallExp *cache_config =
        sbx::buildCudaCallFuncSetCacheConfig(
            fs, sbx::cudaFuncCachePreferL1,
            global_scope_);
    si::appendStatement(sb::buildExprStatement(cache_config),
                        function_body);
    cache_config_done_.insert(fs);
    if (overlap_enabled) {
      if (flag_multistream_boundary_) {
        for (int i = 0; i < smap->getNumDim(); ++i) {
          for (int j = 0; j < 2; ++j) {
            SgFunctionSymbol *fs_boundary =
                si::lookupFunctionSymbolInParentScopes(
                    smap->getRunName() + GetBoundarySuffix(i, j));
            PSAssert(fs_boundary);
            si::appendStatement(
                sb::buildExprStatement(
                    sbx::buildCudaCallFuncSetCacheConfig(
                        fs_boundary, sbx::cudaFuncCachePreferL1,
                        global_scope_)),
                function_body);
          }
        }
      } else {
        SgFunctionSymbol *fs_boundary =
            si::lookupFunctionSymbolInParentScopes(
                smap->getRunName() + GetBoundarySuffix());
        PSAssert(fs_boundary);
        si::appendStatement(
            sb::buildExprStatement(
                sbx::buildCudaCallFuncSetCacheConfig(
                    fs_boundary, sbx::cudaFuncCachePreferL1,
                    global_scope_)),
            function_body);
      }
      
      SgFunctionSymbol *fs_inner =
          rose_util::getFunctionSymbol(smap->run_inner());
      PSAssert(fs_inner);
      si::appendStatement(
          sb::buildExprStatement(
              sbx::buildCudaCallFuncSetCacheConfig(
                  fs_inner, sbx::cudaFuncCachePreferL1,
                  global_scope_)),
          function_body);
    }
  }
  
  // Call the stencil kernel
  // Build an argument list by expanding members of the parameter struct
  // i.e. struct {a, b, c}; -> (s.a, s.b, s.c)
  SgExprListExp *args = sb::buildExprListExp();
  SgExprListExp *args_boundary = sb::buildExprListExp();  
  SgClassDefinition *stencil_def = smap->GetStencilTypeDefinition();
  PSAssert(stencil_def);

  SgVariableDeclaration *grid_dim = cuda_trans_->BuildGridDimDeclaration(
      stencil_name + "_grid_dim",
      BuildGetLocalSize(sb::buildIntVal(0)),
      BuildGetLocalSize(sb::buildIntVal(1)),
      cuda_trans_->BuildBlockDimX(), cuda_trans_->BuildBlockDimY(),
      function_body);

  si::appendStatement(grid_dim, function_body);
  
  // Append the local offset
  for (int i = 0; i < smap->getNumDim()-1; ++i) {
    si::appendExpression(args,
                         BuildGetLocalOffset(sb::buildIntVal(i)));
    if (!flag_multistream_boundary_)
      si::appendExpression(args_boundary,
                           BuildGetLocalOffset(
                               sb::buildIntVal(i)));
  }
  if (!flag_multistream_boundary_)
    si::appendExpression(args_boundary, sb::buildIntVal(overlap_width));

  // Enumerate members of parameter struct
  const SgDeclarationStatementPtrList &members = stencil_def->get_members();
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    SgExpression *arg =
        sb::buildArrowExp(sb::buildVarRefExp(sdecl),
                          sb::buildVarRefExp(member_decl));
    //const SgInitializedNamePtrList &vars = member_decl->get_variables();
    //GridType *gt = tx_->findGridType(vars[0]->get_type());
    SgType *member_type = si::getFirstVarType(member_decl);
    GridType *gt = tx_->findGridType(member_type);
    if (gt) {
      arg = sb::buildPointerDerefExp(
          sb::buildCastExp(
              BuildGridGetDev(arg),
              sb::buildPointerType(cuda_trans_->BuildOnDeviceGridType(gt))));
      // skip the grid index
      ++member;
    }
    if (overlap_enabled && Domain::isDomainType(member_type)) {
      si::appendExpression(
          args,
          BuildDomainShrink(
              sb::buildAddressOfOp(arg),
              sb::buildIntVal(overlap_width)));
    } else {
      si::appendExpression(args, arg);
    }
    si::appendExpression(args_boundary, si::copyExpression(arg));
  }

  // Generate Kernel invocation code
  SgCudaKernelExecConfig *cuda_config =
      sbx::buildCudaKernelExecConfig(sb::buildVarRefExp(grid_dim),
                                     sb::buildVarRefExp(block_dim),
                                     NULL, NULL);
  if (overlap_enabled) {
    SgVarRefExp *inner_stream = sb::buildVarRefExp("stream_inner");
    PSAssert(inner_stream);
    SgCudaKernelExecConfig *cuda_config_inner =
      sbx::buildCudaKernelExecConfig(sb::buildVarRefExp(grid_dim),
                                     sb::buildVarRefExp(block_dim),
                                     NULL, inner_stream);

    SgFunctionSymbol *fs_inner =
        rose_util::getFunctionSymbol(smap->run_inner());
    si::appendStatement(
        sb::buildExprStatement(
            sbx::buildCudaKernelCallExp(sb::buildFunctionRefExp(fs_inner),
                                        args, cuda_config_inner)),
        loop_body);
    // perform boundary exchange concurrently
    FOREACH (sit, load_statements.begin(), load_statements.end()) {
      si::appendStatement(*sit, loop_body);
    }
    LOG_INFO() << "generating call to boundary kernel\n";
    if (overlap_width && !flag_multistream_boundary_) {
      LOG_INFO() << "single-stream version\n";
      SgFunctionSymbol *fs_boundary =
          si::lookupFunctionSymbolInParentScopes(
              smap->getRunName() + GetBoundarySuffix());
      si::appendStatement(
          sb::buildExprStatement(
              sbx::buildCudaKernelCallExp(
                  sb::buildFunctionRefExp(fs_boundary),
                  args_boundary, cuda_config)),
          loop_body);
    } else if (overlap_width) {
      LOG_INFO() << "multi-stream version\n";
      // rose_util::AppendExprStatement(
      //     loop_body,
      //     BuildCudaStreamSynchronize(sb::buildVarRefExp("stream_boundary_copy")));
      // 6 streams for
      int stream_index = 0;
      int num_x_streams = 5;
      for (int j = 0; j < 2; ++j) {
        for (int i = 0; i < num_x_streams; ++i) {
          SgExprListExp *args_boundary_strm =
              isSgExprListExp(si::copyExpression(args_boundary));
          SgExpressionPtrList &expressions =
              args_boundary_strm->get_expressions();
          SgExpression *dom =
              si::copyExpression(expressions.front());
          si::deleteAST(expressions.front());
          expressions.erase(expressions.begin());          
          SgExpression *bd =
              BuildDomainGetBoundary(
                  sb::buildAddressOfOp(dom),
                  0, j, sb::buildIntVal(overlap_width),
                  num_x_streams, i);
          rose_util::PrependExpression(args_boundary_strm, bd);
          int dimz = 512 / (overlap_width * 128);
          SgCudaKernelExecConfig *boundary_config =
              sbx::buildCudaKernelExecConfig(
                  sb::buildIntVal(1),
                  BuildCudaDim3(sb::buildIntVal(overlap_width),
                                sb::buildIntVal(128),
                                sb::buildIntVal(dimz)),
                  NULL, BuildStreamBoundaryKernel(stream_index));
          ++stream_index;
          SgFunctionSymbol *fs_boundary
              = si::lookupFunctionSymbolInParentScopes(
                  smap->getRunName() + GetBoundarySuffix(0, j));
          rose_util::AppendExprStatement(
              loop_body,
              sbx::buildCudaKernelCallExp(
                  sb::buildFunctionRefExp(fs_boundary),
                  args_boundary_strm, boundary_config));
        }
      }
      for (int j = 1; j < 3; ++j) {
        for (int i = 0; i < 2; ++i) {
          SgExprListExp *args_boundary_strm =
              isSgExprListExp(si::copyExpression(args_boundary));
          SgExpressionPtrList &expressions =
              args_boundary_strm->get_expressions();
          SgExpression *dom =
              si::copyExpression(expressions.front());
          si::deleteAST(expressions.front());
          expressions.erase(expressions.begin());
          SgExpression *bd =
              BuildDomainGetBoundary(
                  sb::buildAddressOfOp(dom),
                  j, i, sb::buildIntVal(overlap_width),
                  1, 0);
          rose_util::PrependExpression(args_boundary_strm, bd);
          SgCudaKernelExecConfig *boundary_config;
          if (j == 1) {
            int dimz = 512 / (overlap_width * 128);
            boundary_config = sbx::buildCudaKernelExecConfig(
                sb::buildIntVal(1),
                BuildCudaDim3(sb::buildIntVal(128),
                              sb::buildIntVal(overlap_width),
                              sb::buildIntVal(dimz)),
                NULL, BuildStreamBoundaryKernel(stream_index));
          } else {
            boundary_config = sbx::buildCudaKernelExecConfig(
                sb::buildIntVal(1),
                BuildCudaDim3(sb::buildIntVal(128),
                              sb::buildIntVal(4)),
                NULL, BuildStreamBoundaryKernel(stream_index));
          }
          ++stream_index;
          SgFunctionSymbol *fs_boundary
              = si::lookupFunctionSymbolInParentScopes(
                  smap->getRunName() + GetBoundarySuffix(j, i));
          rose_util::AppendExprStatement(
              loop_body,
              sbx::buildCudaKernelCallExp(
                  sb::buildFunctionRefExp(fs_boundary),
                  args_boundary_strm, boundary_config));
        }
      }
      si::appendStatement(
          sb::buildExprStatement(
              BuildCudaThreadSynchronize()),
          loop_body);
    }
  } else {
    // perform boundary exchange before kernel invocation synchronously
    FOREACH (sit, load_statements.begin(), load_statements.end()) {
      si::appendStatement(*sit, loop_body);
    }
    SgCudaKernelCallExp *c =
        sbx::buildCudaKernelCallExp(sb::buildFunctionRefExp(fs),
                                    args, cuda_config);
    si::appendStatement(sb::buildExprStatement(c), loop_body);
  }
  appendGridSwap(smap, stencil_name, true, loop_body);
  DeactivateRemoteGrids(smap, sdecl, loop_body,
                        remote_grids);

  FixGridAddresses(smap, sdecl, function_body);
}

SgBasicBlock *MPICUDATranslator::BuildRunBody(Run *run) {
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));

  string stencil_param_name = "stencils";
  SgVarRefExp *stencils = sb::buildVarRefExp(stencil_param_name,
                                             block);
  SgVariableDeclaration *block_dim =
      sbx::buildDim3Declaration("block_dim",
                                cuda_trans_->BuildBlockDimX(),
                                cuda_trans_->BuildBlockDimY(),
                                cuda_trans_->BuildBlockDimZ(),
                                block);
  si::appendStatement(block_dim, block);
  
  // build main loop
  SgBasicBlock *loopBody = sb::buildBasicBlock();
  cache_config_done_.clear();
  ENUMERATE(i, it, run->stencils().begin(), run->stencils().end()) {
    ProcessStencilMap(it->second, isSgVarRefExp(si::copyExpression(stencils)),
                      i, run, block, loopBody, block_dim);
  }
  si::deleteAST(stencils);
  SgVariableDeclaration *lv
      = sb::buildVariableDeclaration("i", sb::buildIntType(), NULL, block);
  si::appendStatement(lv, block);
  SgStatement *loopTest =
      sb::buildExprStatement(
          sb::buildLessThanOp(sb::buildVarRefExp(lv),
                              sb::buildVarRefExp("iter", block)));
  SgForStatement *loop =
      sb::buildForStatement(sb::buildAssignStatement(sb::buildVarRefExp(lv),
                                                     sb::buildIntVal(0)),
                            loopTest,
                            sb::buildPlusPlusOp(sb::buildVarRefExp(lv)),
                            loopBody);

  TraceStencilRun(run, loop, block);
  // cudaThreadSynchronize after each loop
  si::insertStatementAfter(
      loop,
      sb::buildExprStatement(BuildCudaThreadSynchronize()));
  return block;
}

static std::string GetTypeDimSig(const std::string &s) {
  for (int i = 1; i <= PS_MAX_DIM; ++i) {
    vector<string> names;
    names.push_back("Float");
    names.push_back("Double");
    FOREACH (it, names.begin(), names.end()) {
      string key = (*it) + toString(i) + "D";
      if (s.find(key) != string::npos) return key;
    }
  }
  return "";
}

SgFunctionDeclaration *
MPICUDATranslator::BuildInteriorKernel(SgFunctionDeclaration *original)
    const {
  SgFunctionDeclaration *inner_version =
      isSgFunctionDeclaration(si::copyStatement(original));
  inner_version->set_name(original->get_name() + inner_prefix_);
  
  PSAssert(inner_version);
  Rose_STL_Container<SgNode*> calls =
      NodeQuery::querySubTree(inner_version, V_SgFunctionCallExp);

  FOREACH (it, calls.begin(), calls.end()) {
    SgFunctionCallExp *fc = isSgFunctionCallExp(*it);
    PSAssert(fc);
    SgFunctionDeclaration *decl = fc->getAssociatedFunctionDeclaration();
    PSAssert(decl);
    SgFunctionSymbol *sym = fc->getAssociatedFunctionSymbol();
    PSAssert(sym);
    string name = sym->get_name();
    if (startswith(name, get_addr_name_)) {
      if (startswith(name, get_addr_no_halo_name_)) continue;
      //replace getaddr with getaddrnohalo
      string key = GetTypeDimSig(name);
      PSAssert(key != "");
      name = get_addr_no_halo_name_ + key;
      LOG_INFO() << "Redirecting to " << name << "\n";
      rose_util::RedirectFunctionCall(
          fc, sb::buildFunctionRefExp(name));
      continue;
    }
    // No redirection for emits
    if (startswith(name, emit_addr_name_)) continue;
    // Redirect intra-kernel calls 
    if (decl->get_definingDeclaration()) {
      rose_util::RedirectFunctionCall(
          fc, sb::buildFunctionRefExp(name + inner_prefix_));
      continue;
    }
  }
  if (cuda_trans_->flag_pre_calc_grid_address()) {
    MPICUDAOptimizer opt(*this);
    opt.GridPreCalcAddr(inner_version);
  }
  return inner_version;
}

static int GetMaximumNumberOfDimensions(SgFunctionDeclaration *func) {
  // TODO: This does not work for intra kernels
  // Possible fix: find the Kernel object, and get the parent
  // func Find The root kernel func, and then use the below logic to
  // get the number of possible max dim.
  SgFunctionParameterList *params = func->get_parameterList();
  SgInitializedNamePtrList &param_args = params->get_args();
  int dim = 0;
  ENUMERATE (i, it, param_args.begin(), param_args.end()) {
    SgInitializedName *p = *it;
    if (!rose_util::IsIntLikeType(p)) {
      dim = i;
      break;
    }
  }
  LOG_DEBUG() << "Kernel (" << string(func->get_name()) << ") max dim: "
              << dim << "\n";
  return dim;
  
}

// Generates per-boundary kernels. 
std::vector<SgFunctionDeclaration*>
MPICUDATranslator::BuildBoundaryKernel(SgFunctionDeclaration *original) {
  std::vector<SgFunctionDeclaration*> bkernels;
  int ndim = GetMaximumNumberOfDimensions(original);
  for (int i = 0; i < ndim; ++i) {
    for (int j = 0; j < 2; ++j) {
      string suffix = GetBoundarySuffix(i, j);
      LOG_INFO() << "Generating device function: "
                  << string(original->get_name() + suffix) << "\n";
      SgFunctionDeclaration *boundary_version =
          isSgFunctionDeclaration(si::copyStatement(original));
      boundary_version->set_name(original->get_name() + suffix);
      PSAssert(boundary_version);
      bkernels.push_back(boundary_version);
      Rose_STL_Container<SgNode*> calls =
          NodeQuery::querySubTree(boundary_version, V_SgFunctionCallExp);

      FOREACH (it, calls.begin(), calls.end()) {
        SgFunctionCallExp *fc = isSgFunctionCallExp(*it);
        PSAssert(fc);
        SgFunctionDeclaration *decl = fc->getAssociatedFunctionDeclaration();
        PSAssert(decl);
        SgFunctionSymbol *sym = fc->getAssociatedFunctionSymbol();
        PSAssert(sym);
        string name = sym->get_name();
        if (startswith(name, get_addr_name_)) {
          if (startswith(name, get_addr_no_halo_name_)) continue;
          if (!fc->attributeExists(StencilIndexAttribute::name)) continue;
          const StencilIndexList &sil =
              static_cast<StencilIndexAttribute*>(
                  fc->getAttribute("StencilIndexList"))->stencil_index_list();

          LOG_DEBUG() << "sil: " << sil << "\n";
          // TODO: the kernel might be used for smaller dimension
          // grids, but that kernel is not recognized as regular even
          // if it's really the case because ndim is used as num_dim param.
          if (!StencilIndexRegularOrder(sil, ndim)) continue;
          int offset = sil[i].offset;
          StencilIndexList t = sil;
          t[i].offset = 0;
          if (!StencilIndexSelf(t, ndim)) continue;
          if ((j == 0 && offset < 0) || ((j == 1) && offset > 0)) {
            continue;
          }
          string key = GetTypeDimSig(name);
          PSAssert(key != "");
          name = get_addr_no_halo_name_ + key;
          LOG_INFO() << "Redirecting to " << name << "\n";
           rose_util::RedirectFunctionCall(
               fc, sb::buildFunctionRefExp(name));
          continue;
        }
        // No redirection for emits
        if (startswith(name, emit_addr_name_)) continue;
        // Redirect intra-kernel calls
        if (decl->get_definingDeclaration()) {
          rose_util::RedirectFunctionCall(
              fc, sb::buildFunctionRefExp(name + suffix));
          continue;
        }
      }
    }
  }
  return bkernels;
}

void MPICUDATranslator::translateKernelDeclaration(
    SgFunctionDeclaration *node) {
  LOG_DEBUG() << "Translating to CUDA kernel\n";
  node->get_functionModifier().setCudaDevice();

  // e.g., PSGrid3DFloat -> __PSGrid3DFloatDev *
  Rose_STL_Container<SgNode*> exps =
      NodeQuery::querySubTree(node, V_SgInitializedName);
  FOREACH (it, exps.begin(), exps.end()) {
    SgInitializedName *exp = isSgInitializedName(*it);
    PSAssert(exp);
    SgType *cur_type = exp->get_type();
    GridType *gt = tx_->findGridType(cur_type);
    // not a grid type
    if (!gt) continue;
    SgType *new_type = sb::buildPointerType(
        cuda_trans_->BuildOnDeviceGridType(gt));
    exp->set_type(new_type);
  }
  
  Rose_STL_Container<SgNode*> gdim_calls =
      NodeQuery::querySubTree(node, V_SgFunctionCallExp);
  SgFunctionSymbol *gdim_dev =
      si::lookupFunctionSymbolInParentScopes("__PSGridDimDev");
  FOREACH (it, gdim_calls.begin(), gdim_calls.end()) {
    SgFunctionCallExp *fc = isSgFunctionCallExp(*it);
    PSAssert(fc);
    if (fc->getAssociatedFunctionSymbol() != grid_dim_get_func_)
      continue;
    rose_util::RedirectFunctionCall(
        fc, sb::buildFunctionRefExp(gdim_dev));               
  }

  if (flag_mpi_overlap_)
    si::insertStatementBefore(node, BuildInteriorKernel(node), false);

  if (flag_multistream_boundary_) {
    std::vector<SgFunctionDeclaration*> boundary_kernels
        = BuildBoundaryKernel(node);
    FOREACH (it, boundary_kernels.begin(), boundary_kernels.end()) {
      // Note: Assertion failure unless autoMovePreprocessingInfo is false.
      si::insertStatementBefore(node, *it, false);
    }
  }
  return;
}

// This is almost equivalent as CUDATranslator::BuildRunKernel, except
// for having offset.
SgFunctionDeclaration *MPICUDATranslator::BuildRunKernel(
    StencilMap *stencil) {
  SgFunctionParameterList *params = sb::buildFunctionParameterList();
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);
  SgInitializedName *dom_arg = NULL;
  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();
  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    si::appendArg(params,
                  sb::buildInitializedName("offset" + toString(i),
                                           sb::buildIntType()));
  }
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = sb::buildInitializedName(
        vars[0]->get_name(), vars[0]->get_type());
    SgType *type = arg->get_type();
    LOG_DEBUG() << "type: " << type->unparseToString() << "\n";
    if (Domain::isDomainType(type)) {
      if (!dom_arg) { dom_arg = arg; }
    } else if (GridType::isGridType(type)) {
      SgType *gt = cuda_trans_->BuildOnDeviceGridType(
          tx_->findGridType(type));
      arg->set_type(gt);
      // skip the grid index
      ++member;
    }
    si::appendArg(params, arg);
  }
  PSAssert(dom_arg);

  LOG_INFO() << "Declaring and defining function named "
             << stencil->getRunName() << "\n";
  SgFunctionDeclaration *run_func =
      sb::buildDefiningFunctionDeclaration(stencil->getRunName(),
                                           sb::buildVoidType(),
                                           params, global_scope_);
  
  si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
  run_func->get_functionModifier().setCudaKernel();
  SgBasicBlock *func_body = BuildRunKernelBody(stencil, dom_arg);
  rose_util::ReplaceFuncBody(run_func, func_body);  
  rose_util::AddASTAttribute(run_func,
                             new RunKernelAttribute(stencil));
  return run_func;
}

SgFunctionDeclaration *MPICUDATranslator::BuildRunInteriorKernel(
    StencilMap *stencil) {

  if (!flag_mpi_overlap_) return NULL;
  
  SgFunctionParameterList *params = sb::buildFunctionParameterList();
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  SgInitializedName *dom_arg = NULL;

  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();
  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    si::appendArg(params,
                  sb::buildInitializedName("offset" + toString(i),
                                           sb::buildIntType()));
  }
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = sb::buildInitializedName(
        vars[0]->get_name(), vars[0]->get_type());
    SgType *type = arg->get_type();
    LOG_DEBUG() << "type: " << type->unparseToString() << "\n";
    if (Domain::isDomainType(type)) {
      if (!dom_arg) { dom_arg = arg; }
    } else if (GridType::isGridType(type)) {
      SgType *gt = cuda_trans_->BuildOnDeviceGridType(
          tx_->findGridType(type));
      arg->set_type(gt);
      // skip the grid index
      ++member;
    }
    si::appendArg(params, arg);
  }
  PSAssert(dom_arg);

  string func_name = stencil->getRunName() + inner_prefix_;
  LOG_INFO() << "Declaring and defining function named "
             << func_name << "\n";
  SgFunctionDeclaration *run_func =
      sb::buildDefiningFunctionDeclaration(func_name,
                                           sb::buildVoidType(),
                                           params, global_scope_);
  
  si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
  run_func->get_functionModifier().setCudaKernel();
  SgBasicBlock *func_body =
      BuildRunInteriorKernelBody(stencil, dom_arg);
  rose_util::ReplaceFuncBody(run_func, func_body);
  return run_func;
}

void MPICUDATranslator::BuildFunctionParamList(
    SgClassDefinition *param_struct_def,
    SgFunctionParameterList *&params,
    SgInitializedName *&grid_arg,
    SgInitializedName *&dom_arg) {
  LOG_DEBUG() << "Building function parameter list\n";
  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();

  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = sb::buildInitializedName(
        vars[0]->get_name(), vars[0]->get_type());
    SgType *type = arg->get_type();
    if (Domain::isDomainType(type)) {
      if (!dom_arg) {
        dom_arg = arg;
      }
    } else if (GridType::isGridType(type)) {
      SgType *gt = cuda_trans_->BuildOnDeviceGridType(
          tx_->findGridType(type));
      arg->set_type(gt);
      if (!grid_arg) {
        grid_arg = arg;
      }
      // skip the grid index
      ++member;
    }
    si::appendArg(params, arg);
  }
  return;
}

SgFunctionDeclarationPtrVector
MPICUDATranslator::BuildRunMultiStreamBoundaryKernel(
    StencilMap *stencil) {
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  std::vector<SgFunctionDeclaration*> run_funcs;

  for (int i = 0; i < stencil->getNumDim(); ++i) {
    for (int j = 0; j < 2; ++j) {
      bool fw = j;
      string name = stencil->getRunName() + GetBoundarySuffix(i, fw);
      LOG_INFO() << "Generating global function: " << name << "\n";
      SgFunctionParameterList *params = sb::buildFunctionParameterList();
      SgInitializedName *grid_arg = NULL;
      SgInitializedName *dom_arg = NULL;
      BuildFunctionParamList(param_struct_def, params,
                             grid_arg, dom_arg);
      PSAssert(dom_arg);
      SgFunctionDeclaration *run_func =
          sb::buildDefiningFunctionDeclaration(
              name, sb::buildVoidType(),
              params, global_scope_);
      si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
      run_func->get_functionModifier().setCudaKernel();
      SgBasicBlock *func_body = BuildRunMultiStreamBoundaryKernelBody(
          stencil, grid_arg, dom_arg, i, j);
      rose_util::ReplaceFuncBody(run_func, func_body);
      run_funcs.push_back(run_func);
    }
  }
  return run_funcs;
}

SgFunctionDeclarationPtrVector
MPICUDATranslator::BuildRunBoundaryKernel(StencilMap *stencil) {
  std::vector<SgFunctionDeclaration*> run_funcs;
  if (!flag_mpi_overlap_) return run_funcs;;
  if (flag_multistream_boundary_)
    return BuildRunMultiStreamBoundaryKernel(stencil);

  SgFunctionParameterList *params = sb::buildFunctionParameterList();
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  SgInitializedName *grid_arg = NULL;
  SgInitializedName *dom_arg = NULL;

  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();

  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    si::appendArg(params,
                  sb::buildInitializedName("offset" + toString(i),
                                           sb::buildIntType()));
  }
  si::appendArg(params,
                sb::buildInitializedName(boundary_kernel_width_name_,
                                         sb::buildIntType()));
  
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = sb::buildInitializedName(
        vars[0]->get_name(), vars[0]->get_type());
    SgType *type = arg->get_type();
    LOG_DEBUG() << "type: " << type->unparseToString() << "\n";
    if (Domain::isDomainType(type)) {
      if (!dom_arg) {
        dom_arg = arg;
      }
    } else if (GridType::isGridType(type)) {
      SgType *gt = cuda_trans_->BuildOnDeviceGridType(
          tx_->findGridType(type));
      arg->set_type(gt);
      if (!grid_arg) { grid_arg = arg;  }
      // skip the grid index
      ++member;
    }
    si::appendArg(params, arg);
  }
  PSAssert(grid_arg);
  PSAssert(dom_arg);

  LOG_INFO() << "Declaring and defining function named "
             << stencil->getRunName() << "\n";
  SgFunctionDeclaration *run_func =
      sb::buildDefiningFunctionDeclaration(stencil->getRunName()
                                           + boundary_suffix_,
                                           sb::buildVoidType(),
                                           params, global_scope_);
  
  si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
  run_func->get_functionModifier().setCudaKernel();
  SgBasicBlock *func_body = BuildRunBoundaryKernelBody(
      stencil, dom_arg);
  rose_util::ReplaceFuncBody(run_func, func_body);
  run_funcs.push_back(run_func);
  return run_funcs;
}

SgBasicBlock* MPICUDATranslator::BuildRunMultiStreamBoundaryKernelBody(
    StencilMap *stencil,
    SgInitializedName *grid_arg,
    SgInitializedName *dom_arg, int dim, bool fw) {
  LOG_DEBUG() << "Generating run boundary kernel body\n";
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  SgExpression *min_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_min"));
  SgExpression *max_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_max"));
  
  SgExpressionPtrList index_args;
  PSAssert(stencil->getNumDim() == 3);

  SgVariableDeclaration *x_index = sb::buildVariableDeclaration
      ("x", sb::buildIntType(), NULL, block);
  SgVariableDeclaration *y_index = sb::buildVariableDeclaration
      ("y", sb::buildIntType(), NULL, block);
  SgVariableDeclaration *z_index = sb::buildVariableDeclaration
      ("z", sb::buildIntType(), NULL, block);

  si::appendStatement(x_index, block);
  si::appendStatement(y_index, block);
  si::appendStatement(z_index, block);

  index_args.push_back(sb::buildVarRefExp(x_index));
  index_args.push_back(sb::buildVarRefExp(y_index));
  index_args.push_back(sb::buildVarRefExp(z_index));  

  SgVariableDeclaration *loop_index = x_index;
  SgStatement *loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),
      sb::buildAddOp(sbx::buildCudaIdxExp(sbx::kThreadIdxX),
                     sb::buildPntrArrRefExp(min_field,
                                            sb::buildIntVal(0))));
  SgStatement *loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildPntrArrRefExp(max_field,
                                                 sb::buildIntVal(0))));
  SgExpression *loop_incr =
      sb::buildPlusAssignOp(sb::buildVarRefExp(loop_index),
                            sbx::buildCudaIdxExp(sbx::kBlockDimX));

  SgBasicBlock *loop_body = sb::buildBasicBlock();
  SgExprListExp *kernel_args=
      cuda_trans_->BuildKernelCallArgList(stencil, index_args);
  string kernel_name = stencil->getKernel()->get_name()
      + GetBoundarySuffix(dim, fw);
  SgFunctionDeclaration *kernel =
      sb::buildNondefiningFunctionDeclaration(
          kernel_name,
          stencil->getKernel()->get_type()->get_return_type(),
          isSgFunctionParameterList(
              si::copyStatement(stencil->getKernel()->get_parameterList())),
          global_scope_);
  SgFunctionCallExp *kernel_call =
      sb::buildFunctionCallExp(sb::buildFunctionRefExp(kernel), kernel_args);
  si::appendStatement(sb::buildExprStatement(kernel_call), loop_body);

  SgStatement *loop
      = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);

  // Creates doubly nested loops with y and z dimensions
  for (int i = 1; i <= 2; i++) {
    SgExpression *threadIdx = NULL;
    SgExpression *blockDim = NULL;
    if (i == 1) {
      loop_index = y_index;
      threadIdx = sbx::buildCudaIdxExp(sbx::kThreadIdxY);
      blockDim = sbx::buildCudaIdxExp(sbx::kBlockDimY);
    } else if (i == 2) {
      loop_index = z_index;
      threadIdx = sbx::buildCudaIdxExp(sbx::kThreadIdxZ);
      blockDim = sbx::buildCudaIdxExp(sbx::kBlockDimZ);
    }
    loop_init = sb::buildAssignStatement(
        sb::buildVarRefExp(loop_index),
        sb::buildAddOp(threadIdx,
                       sb::buildPntrArrRefExp(
                           si::copyExpression(min_field),
                           sb::buildIntVal(i))));
    loop_test = sb::buildExprStatement(
        sb::buildLessThanOp(
            sb::buildVarRefExp(loop_index),
            sb::buildPntrArrRefExp(si::copyExpression(max_field),
                                   sb::buildIntVal(i))));
    loop_incr = sb::buildPlusAssignOp(
        sb::buildVarRefExp(loop_index), blockDim);
    loop = sb::buildForStatement(loop_init, loop_test, loop_incr, loop);
  }
  si::appendStatement(loop, block);

  return block;
}

bool MPICUDATranslator::translateGetKernel(SgFunctionCallExp *node,
                                           SgInitializedName *gv,
                                           bool is_periodic) {
  // 
  // *((gt->getElmType())__PSGridGetAddressND(g, x, y, z))

  GridType *gt = tx_->findGridType(gv->get_type());
  int nd = gt->getNumDim();
  SgScopeStatement *scope = getContainingScopeStatement(node);  
  
  string get_address_name = get_addr_name_ +  GetTypeDimName(gt);
  string get_address_no_halo_name = get_addr_no_halo_name_ +  GetTypeDimName(gt);
  SgFunctionRefExp *get_address = NULL;
  const StencilIndexList *sil = tx_->findStencilIndex(node);
  PSAssert(sil);
  LOG_DEBUG() << "Stencil index: " << *sil << "\n";
  if (StencilIndexSelf(*sil, nd)) {
    get_address = sb::buildFunctionRefExp(get_address_no_halo_name,
                                          global_scope_);
  } else if (StencilIndexRegularOrder(*sil, nd)) {
    for (int i = 0; i < nd; ++i) {
      int offset = (*sil)[i].offset;
      if (!offset) continue;
      string method_name = 
          get_address_name + "_" +
          toString(i) + "_" + ((offset < 0) ? "bw" : "fw");
      LOG_INFO() << "Using " << method_name << "\n";
      get_address = sb::buildFunctionRefExp(method_name, global_scope_);
      break;
    }
  } else {
    get_address = sb::buildFunctionRefExp(get_address_name,
                                          global_scope_);
  }
  SgExprListExp *args = isSgExprListExp(
      si::copyExpression(node->get_args()));
  rose_util::PrependExpression(args, 
                               sb::buildVarRefExp(gv->get_name(), scope));
  SgFunctionCallExp *get_address_exp
      = sb::buildFunctionCallExp(get_address, args);
  // refactoring: merge the two attributes
  rose_util::AddASTAttribute<StencilIndexAttribute>(
      get_address_exp,
      new StencilIndexAttribute(*sil));
  rose_util::CopyASTAttribute<GridCallAttribute>(
      get_address_exp, node, false);
  SgExpression *x = sb::buildPointerDerefExp(get_address_exp);
  rose_util::CopyASTAttribute<GridGetAttribute>(x, node, false);  
  si::replaceExpression(node, x);
  return true;
}

void MPICUDATranslator::FixAST() {
  if (validate_ast_) {
    si::fixVariableReferences(project_);
  }
}

} // namespace translator
} // namespace physis
