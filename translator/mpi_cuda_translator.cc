// Copyright 2011, Tokyo Institute of Technology.
// All rights reserved.
//
// This file is distributed under the license described in
// LICENSE.txt.
//
// Author: Naoya Maruyama (naoya@matsulab.is.titech.ac.jp)

#include "translator/mpi_cuda_translator.h"

#include "translator/translation_context.h"
#include "translator/translation_util.h"
#include "translator/mpi_runtime_builder.h"
#include "translator/mpi_cuda_runtime_builder.h"
#include "translator/reference_runtime_builder.h"
#include "translator/cuda_runtime_builder.h"
#include "translator/SageBuilderEx.h"
#include "translator/cuda_builder.h"
#include "translator/rose_util.h"
#include "translator/runtime_builder.h"
#include "translator/mpi_cuda_optimizer.h"
#include "translator/rose_ast_attribute.h"

namespace pu = physis::util;
namespace sb = SageBuilder;
namespace si = SageInterface;
namespace sbx = physis::translator::SageBuilderEx;

#define BLOCK_DIM_X_DEFAULT (64)
#define BLOCK_DIM_Y_DEFAULT (4)
#define BLOCK_DIM_Z_DEFAULT (1)

namespace physis {
namespace translator {

std::string MPICUDATranslator::GetBoundarySuffix(int dim, bool fw) {
  return boundary_suffix_ + "_" +
      toString(dim+1) + "_" + (fw ? "fw" : "bw");
}

std::string MPICUDATranslator::GetBoundarySuffix() {
  return boundary_suffix_;
}


MPICUDATranslator::MPICUDATranslator(const Configuration &config)
    : MPITranslator(config),
    block_dim_x_(BLOCK_DIM_X_DEFAULT),
    block_dim_y_(BLOCK_DIM_Y_DEFAULT),
      block_dim_z_(BLOCK_DIM_Z_DEFAULT),
      boundary_kernel_width_name_("halo_width"),
      inner_prefix_("_inner"),
      boundary_suffix_("_boundary") {  
  grid_create_name_ = "__PSGridNewMPI";
  target_specific_macro_ = "PHYSIS_MPI_CUDA";
  flag_using_dimy_as_dimz_ = false;
  flag_pre_calc_grid_address_ = false;
  flag_multistream_boundary_ = false;
  const pu::LuaValue *lv
      = config.Lookup(Configuration::CUDA_PRE_CALC_GRID_ADDRESS);
  if (lv) {
    PSAssert(lv->get(flag_pre_calc_grid_address_));
  }
  if (flag_pre_calc_grid_address_) {
    LOG_INFO() << "Optimization of address calculation enabled.\n";
  }
  // Redefine the block size if specified in the configuration file
  lv = config.Lookup(Configuration::CUDA_BLOCK_SIZE);
  if (lv) {
    const pu::LuaTable *tbl = lv->getAsLuaTable();
    PSAssert(tbl);
    std::vector<double> v;
    PSAssert(tbl->get(v));
    block_dim_x_ = (int)v[0];
    block_dim_y_ = (int)v[1];
    block_dim_z_ = (int)v[2];
  }
  lv = config.Lookup(Configuration::MULTISTREAM_BOUNDARY);
  if (lv) {
    PSAssert(lv->get(flag_multistream_boundary_));
  }
  if (flag_multistream_boundary_) {
    LOG_INFO() << "Multistream boundary enabled\n";
  }
}

SgBasicBlock* MPICUDATranslator::generateRunKernelBody(
    StencilMap *stencil,
    SgInitializedName *grid_arg,
    SgInitializedName *dom_arg) {
  LOG_DEBUG() << "Generating run kernel body\n";
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  int dim = stencil->getNumDim();  
  SgExpression *domain = sb::buildVarRefExp(dom_arg);
  SgExpression *min_field = BuildDomMinRef(domain);
  SgExpression *max_field = BuildDomMaxRef(domain);
  vector<SgExpression*> offset_exprs;
  for (int i = 0; i < dim-1; ++i) {
    offset_exprs.push_back(sb::buildVarRefExp("offset" + toString(i)));
  }
  
  SgExpressionPtrList index_args;
  if (dim < 3) {
    LOG_ERROR() << "not supported yet.\n";
  } else if (dim == 3) {
    // Generate a z-loop
    SgVariableDeclaration *loop_index;
    SgStatement *loop_init, *loop_test;
    SgExpression *loop_incr;
    SgBasicBlock *loop_body;
    SgVariableDeclaration *x_index, *y_index, *z_index;
    x_index = sb::buildVariableDeclaration("x", sb::buildIntType(),
                                           NULL, block);
    y_index = sb::buildVariableDeclaration("y", sb::buildIntType(),
                                           NULL, block);
    z_index = sb::buildVariableDeclaration("z", sb::buildIntType(),
                                           NULL, block);
    block->append_statement(x_index);    
    block->append_statement(y_index);
    // NOTE: z_index is going to be appended again if
    //flag_using_dimy_as_dimz_ is false, so this is commented out, but
    // not sure this is acutally correct.
    //block->append_statement(z_index);

    index_args.push_back(sb::buildVarRefExp(x_index));
    index_args.push_back(sb::buildVarRefExp(y_index));

    if (flag_using_dimy_as_dimz_) {
      // blockIdx_y = blockIdx.x / (nx/dim_x);
      // blockIdx_x = blockIdx.x - blockIdx_y*(nx/dim_x);
      // x = dim_x * blockIdx_x + threadIdx.x;
      // y = dim_y * blockIdx_y + threadIdx.y;
      // z = dim_z * blockIdx.y;
      SgExpression *nx_div_dim_x =
          sb::buildDivideOp(
              sbx::buildGridDimVarExp(sb::buildVarRefExp(grid_arg), 0),
              BuildBlockDimX());
      SgExpression *block_idx_y =
          sb::buildDivideOp(sbx::buildCudaIdxExp(sbx::kBlockIdxX), nx_div_dim_x);
      SgExpression *block_idx_x =
          sb::buildSubtractOp(
              sbx::buildCudaIdxExp(sbx::kBlockIdxX),
              sb::buildMultiplyOp(block_idx_y, nx_div_dim_x));
      x_index->reset_initializer(
          sb::buildAssignInitializer(
              sb::buildAddOp(sb::buildMultiplyOp(BuildBlockDimX(), block_idx_x),
                  sbx::buildCudaIdxExp(sbx::kThreadIdxX))));
      y_index->reset_initializer(
          sb::buildAssignInitializer(
              sb::buildAddOp(
                  sb::buildMultiplyOp(BuildBlockDimY(), block_idx_y),
                  sbx::buildCudaIdxExp(sbx::kThreadIdxY))));
      z_index->reset_initializer(
          sb::buildAssignInitializer(
              sb::buildMultiplyOp(BuildBlockDimZ(),
                  sbx::buildCudaIdxExp(sbx::kBlockIdxY))));
      loop_index = sb::buildVariableDeclaration("_k",
                                                sb::buildIntType(),
                                                NULL, block);
      loop_init = sb::buildAssignStatement(
          sb::buildVarRefExp(loop_index), sb::buildIntVal(0));

      loop_test = sb::buildExprStatement(
          sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                              BuildBlockDimZ()));
      index_args.push_back(sb::buildAddOp(sb::buildVarRefExp(z_index),
                                          sb::buildVarRefExp(loop_index)));
    } else {
      // x = blockIdx.x * blockDim.x + threadIdx.x;
      SgExpression *dom_min_z = sb::buildPntrArrRefExp(min_field,
                                                       sb::buildIntVal(2));
      SgExpression *dom_max_z = sb::buildPntrArrRefExp(max_field,
                                                       sb::buildIntVal(2));
      x_index->reset_initializer(
          sb::buildAssignInitializer(
              sb::buildAddOp(
                  sb::buildAddOp(sb::buildMultiplyOp(
                      sbx::buildCudaIdxExp(sbx::kBlockIdxX),
                      sbx::buildCudaIdxExp(sbx::kBlockDimX)),
                                 sbx::buildCudaIdxExp(sbx::kThreadIdxX)),
                  offset_exprs[0])));
      

      // y = blockIdx.y * blockDim.y + threadIdx.y;
      y_index->reset_initializer(
          sb::buildAssignInitializer(
              sb::buildAddOp(
                  sb::buildAddOp(sb::buildMultiplyOp(
                      sbx::buildCudaIdxExp(sbx::kBlockIdxY),
                      sbx::buildCudaIdxExp(sbx::kBlockDimY)),
                                 sbx::buildCudaIdxExp(sbx::kThreadIdxY)),
                  offset_exprs[1])));
      
      
      loop_index = z_index;
      loop_init = sb::buildAssignStatement(
          sb::buildVarRefExp(loop_index), dom_min_z);
      loop_test = sb::buildExprStatement(
          sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                              dom_max_z));
      index_args.push_back(sb::buildVarRefExp(loop_index));
    }
    SgVariableDeclaration* t[] = {x_index, y_index};
    vector<SgVariableDeclaration*> range_checking_idx(t, t + 2);
    
    block->append_statement(
        BuildDomainInclusionCheck(range_checking_idx, domain));
    
    block->append_statement(loop_index);

    loop_incr =
        sb::buildPlusPlusOp(sb::buildVarRefExp(loop_index));

    loop_body = sb::buildBasicBlock();
    SgFunctionCallExp *kernel_call
        = generateKernelCall(stencil, index_args);
    loop_body->append_statement(sb::buildExprStatement(kernel_call));

    SgStatement *loop
        = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);
    if (flag_using_dimy_as_dimz_) {
      SgPragmaDeclaration *pragma_unroll =
          sb::buildPragmaDeclaration("unroll", block);
      block->append_statement(pragma_unroll);
    }
    block->append_statement(loop);
  }

  return block;
}

SgBasicBlock* MPICUDATranslator::generateRunInnerKernelBody(
    StencilMap *stencil,
    SgInitializedName *grid_arg,
    SgInitializedName *dom_arg) {

  
  LOG_DEBUG() << "Generating run kernel body\n";
  SgBasicBlock *body = generateRunKernelBody(stencil,
                                             grid_arg, dom_arg);
  const std::string &normal_kernel_name = stencil->getKernel()->get_name();
  const std::string &inner_kernel_name = normal_kernel_name 
                                         + inner_prefix_;
  LOG_DEBUG() << "normal kernel name: "
              << normal_kernel_name << "\n";
  LOG_DEBUG() << "inner kernel name: "
              << inner_kernel_name << "\n";
  SgFunctionDeclaration *inner_kernel =
      sb::buildNondefiningFunctionDeclaration(
          inner_kernel_name,
          stencil->getKernel()->get_type()->get_return_type(),
          stencil->getKernel()->get_parameterList(),
          global_scope_);
  
  //si::insertStatement(stencil->getKernel(), inner_kernel);
  
  rose_util::RedirectFunctionCalls(body,
                                   normal_kernel_name,
                                   sb::buildFunctionRefExp(inner_kernel));
  return body;
}

SgBasicBlock* MPICUDATranslator::generateRunBoundaryKernelBody(
    StencilMap *stencil,
    SgInitializedName *grid_arg,
    SgInitializedName *dom_arg) {
  LOG_DEBUG() << "Generating run boundary kernel body\n";
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  int dim = stencil->getNumDim();  
  SgExpression *domain = sb::buildVarRefExp(dom_arg);
  SgExpression *min_field = BuildDomMinRef(domain);
  SgExpression *max_field = BuildDomMaxRef(domain);
  SgExpression *width = sb::buildVarRefExp(boundary_kernel_width_name_);
  vector<SgExpression*> offset_exprs;
  for (int i = 0; i < dim-1; ++i) {
    offset_exprs.push_back(sb::buildVarRefExp("offset" + toString(i)));
  }
  
  SgExpressionPtrList index_args;
  if (dim < 3) {
    LOG_ERROR() << "not supported yet.\n";
    PSAbort(1);
  }

  // Generate a z-loop
  SgVariableDeclaration *loop_index;
  SgStatement *loop_init, *loop_test;
  SgExpression *loop_incr;
  SgBasicBlock *loop_body;
  SgVariableDeclaration *x_index, *y_index, *z_index;
  x_index = sb::buildVariableDeclaration("x", sb::buildIntType(),
                                         NULL, block);
  y_index = sb::buildVariableDeclaration("y", sb::buildIntType(),
                                         NULL, block);
  z_index = sb::buildVariableDeclaration("z", sb::buildIntType(),
                                         NULL, block);
  block->append_statement(x_index);    
  block->append_statement(y_index);
  // NOTE: z_index is going to be appended again if
  //flag_using_dimy_as_dimz_ is false, so this is commented out, but
  // not sure this is acutally correct.
  //block->append_statement(z_index);

  index_args.push_back(sb::buildVarRefExp(x_index));
  index_args.push_back(sb::buildVarRefExp(y_index));

  // x = blockIdx.x * blockDim.x + threadIdx.x;
  SgExpression *dom_min_z = sb::buildPntrArrRefExp(min_field,
                                                   sb::buildIntVal(2));
  SgExpression *dom_max_z = sb::buildPntrArrRefExp(max_field,
                                                   sb::buildIntVal(2));
  x_index->reset_initializer(
      sb::buildAssignInitializer(
          sb::buildAddOp(
              sb::buildAddOp(sb::buildMultiplyOp(
                  sbx::buildCudaIdxExp(sbx::kBlockIdxX),
                  sbx::buildCudaIdxExp(sbx::kBlockDimX)),
                             sbx::buildCudaIdxExp(sbx::kThreadIdxX)),
              offset_exprs[0])));
      

  // y = blockIdx.y * blockDim.y + threadIdx.y;
  y_index->reset_initializer(
      sb::buildAssignInitializer(
          sb::buildAddOp(
              sb::buildAddOp(sb::buildMultiplyOp(
                  sbx::buildCudaIdxExp(sbx::kBlockIdxY),
                  sbx::buildCudaIdxExp(sbx::kBlockDimY)),
                             sbx::buildCudaIdxExp(sbx::kThreadIdxY)),
              offset_exprs[1])));
      
  loop_index = z_index;
  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index), dom_min_z);
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildAddOp(dom_min_z, width)));
  
  index_args.push_back(sb::buildVarRefExp(loop_index));

  SgVariableDeclaration* t[] = {x_index, y_index};
  vector<SgVariableDeclaration*> range_checking_idx(t, t + 2);
    
  block->append_statement(
      BuildDomainInclusionCheck(range_checking_idx, domain));
    
  block->append_statement(loop_index);

  loop_incr =
      sb::buildPlusPlusOp(sb::buildVarRefExp(loop_index));

  loop_body = sb::buildBasicBlock();
  SgFunctionCallExp *kernel_call
      = generateKernelCall(stencil, index_args);
  loop_body->append_statement(sb::buildExprStatement(kernel_call));

  SgStatement *loop
      = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);
  block->append_statement(loop);


  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),  sb::buildAddOp(dom_min_z, width));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildSubtractOp(dom_max_z, width)));
  loop = sb::buildForStatement(loop_init, loop_test,
                               loop_incr, loop_body);
  block->append_statement(BuildDomainInclusionInnerCheck(
      range_checking_idx, domain, width, loop));

  
  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index), sb::buildSubtractOp(dom_max_z,
                                                          width));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          dom_max_z));
  loop = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);
  block->append_statement(loop);

  return block;
}


SgExpression *MPICUDATranslator::BuildBlockDimX() {
  return sb::buildIntVal(block_dim_x_);
}

SgExpression *MPICUDATranslator::BuildBlockDimY() {
  return sb::buildIntVal(block_dim_y_);  
}

SgExpression *MPICUDATranslator::BuildBlockDimZ() {
  return sb::buildIntVal(block_dim_z_);
}

SgIfStmt *MPICUDATranslator::BuildDomainInclusionCheck(
    const vector<SgVariableDeclaration*> &indices,
    SgExpression *dom_ref) const {
  // check x and y domain coordinates, like:
  // if (x < dom.local_min[0] || x >= dom.local_max[0] ||
  //     y < dom.local_min[1] || y >= dom.local_max[1]) {
  //   return;
  // }
  
  SgExpression *test_all = NULL;
  ENUMERATE (dim, index_it, indices.begin(), indices.end()) {
    SgExpression *idx = sb::buildVarRefExp(*index_it);
    SgExpression *test = sb::buildOrOp(
        sb::buildLessThanOp(idx, BuildDomMinRef(dom_ref, dim)),
        sb::buildGreaterOrEqualOp(idx, BuildDomMaxRef(dom_ref, dim)));
    if (test_all) {
      test_all = sb::buildOrOp(test_all, test);
    } else {
      test_all = test;
    }
  }
  SgIfStmt *ifstmt =
      sb::buildIfStmt(test_all, sb::buildReturnStmt(), NULL);
  return ifstmt;
}

SgIfStmt *MPICUDATranslator::BuildDomainInclusionInnerCheck(
    const vector<SgVariableDeclaration*> &indices,
    SgExpression *dom_ref, SgExpression *width,
    SgStatement *ifclause) const {
  SgExpression *test_all = NULL;
  ENUMERATE (dim, index_it, indices.begin(), indices.end()) {
    SgExpression *idx = sb::buildVarRefExp(*index_it);
    SgExpression *test = sb::buildOrOp(
        sb::buildLessThanOp(idx,
                            sb::buildAddOp(BuildDomMinRef(dom_ref, dim),
                                           width)),
        sb::buildGreaterOrEqualOp(
            idx,
            sb::buildSubtractOp(BuildDomMaxRef(dom_ref, dim), width)));
    if (test_all) {
      test_all = sb::buildOrOp(test_all, test);
    } else {
      test_all = test;
    }
  }
  SgIfStmt *ifstmt = sb::buildIfStmt(test_all, ifclause, NULL);
  return ifstmt;
}

void MPICUDATranslator::ProcessStencilMap(
    StencilMap *smap,
    SgVarRefExp *stencils,
    int stencil_map_index,
    Run *run,
    SgScopeStatement *function_body,
    SgScopeStatement *loop_body,
    SgVariableDeclaration *block_dim) {
  string stencil_name = "s" + toString(stencil_map_index);
  SgExpression *idx = sb::buildIntVal(stencil_map_index);
  SgType *stencil_ptr_type = sb::buildPointerType(smap->stencil_type());
  SgAssignInitializer *init =
      sb::buildAssignInitializer(
          sb::buildCastExp(
              sb::buildPntrArrRefExp(stencils, idx),
              stencil_ptr_type), stencil_ptr_type);
  SgVariableDeclaration *sdecl
      = sb::buildVariableDeclaration(stencil_name, stencil_ptr_type,
                                     init, function_body);
  SgVarRefExp *stencil_var = sb::buildVarRefExp(sdecl);
  function_body->append_statement(sdecl);

  SgInitializedNamePtrList remote_grids;
  SgStatementPtrList load_statements;
  bool overlap_eligible;
  int overlap_width;
  GenerateLoadRemoteGridRegion(smap, stencil_var, run, loop_body,
                               remote_grids, load_statements,
                               overlap_eligible, overlap_width);
  bool overlap_enabled = flag_mpi_overlap_ &&  overlap_eligible;
  if (overlap_enabled) {
    LOG_INFO() << "Generating overlapping code\n";
  } else {
    LOG_INFO() << "Generating non-overlapping code\n";    
  }
  // run kernel function
  SgFunctionSymbol *fs = rose_util::getFunctionSymbol(smap->run());
  PSAssert(fs);
  if (cache_config_done_.find(fs) == cache_config_done_.end()) {
    SgFunctionCallExp *cache_config =
        sbx::buildCudaCallFuncSetCacheConfig(fs,
                                             sbx::cudaFuncCachePreferL1);
    function_body->append_statement(sb::buildExprStatement(cache_config));
    cache_config_done_.insert(fs);
    if (overlap_enabled) {
      if (flag_multistream_boundary_) {
        for (int i = 0; i < smap->getNumDim(); ++i) {
          for (int j = 0; j < 2; ++j) {
            SgFunctionSymbol *fs_boundary =
                si::lookupFunctionSymbolInParentScopes(
                    smap->getRunName() + GetBoundarySuffix(i, j));
            PSAssert(fs_boundary);
            function_body->append_statement(
                sb::buildExprStatement(
                    sbx::buildCudaCallFuncSetCacheConfig(
                        fs_boundary, sbx::cudaFuncCachePreferL1)));
          }
        }
      } else {
        SgFunctionSymbol *fs_boundary =
            si::lookupFunctionSymbolInParentScopes(
                smap->getRunName() + GetBoundarySuffix());
        PSAssert(fs_boundary);
        function_body->append_statement(
            sb::buildExprStatement(
                sbx::buildCudaCallFuncSetCacheConfig(
                    fs_boundary, sbx::cudaFuncCachePreferL1)));
      }
      
      SgFunctionSymbol *fs_inner =
          rose_util::getFunctionSymbol(smap->run_inner());
      PSAssert(fs_inner);
      function_body->append_statement(
          sb::buildExprStatement(
              sbx::buildCudaCallFuncSetCacheConfig(
                  fs_inner, sbx::cudaFuncCachePreferL1)));
    
    }
  }
  
  // Call the stencil kernel
  // Build an argument list by expanding members of the parameter struct
  // i.e. struct {a, b, c}; -> (s.a, s.b, s.c)
  SgExprListExp *args = sb::buildExprListExp();
  SgExprListExp *args_boundary = sb::buildExprListExp();  
  //string stencil_name = "s" + toString(stencil_idx);
  //SgVarRefExp *stencil_var = sb::buildVarRefExp(stencil_name);
  SgClassDefinition *stencil_def = smap->GetStencilTypeDefinition();
  PSAssert(stencil_def);

  SgVariableDeclaration *grid_dim;
  if (flag_using_dimy_as_dimz_) {
    grid_dim =
        generateGridDimDeclaration3D(stencil_name + "_grid_dim",
                                     stencil_var,
                                     BuildBlockDimX(),
                                     BuildBlockDimY(),
                                     function_body);
  } else {
    grid_dim =
        generateGridDimDeclaration2D(stencil_name + "_grid_dim",
                                     stencil_var,
                                     BuildBlockDimX(),
                                     BuildBlockDimY(),
                                     function_body);
  }
  function_body->append_statement(grid_dim);
  
  // Append the local offset
  for (int i = 0; i < smap->getNumDim()-1; ++i) {
    args->append_expression(BuildGetLocalOffset(sb::buildIntVal(i)));
    if (!flag_multistream_boundary_)
      args_boundary->append_expression(BuildGetLocalOffset(
          sb::buildIntVal(i)));    
  }
  if (!flag_multistream_boundary_)
    args_boundary->append_expression(sb::buildIntVal(overlap_width));

  // Enumerate members of parameter struct
  const SgDeclarationStatementPtrList &members = stencil_def->get_members();
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    SgExpression *arg =
        sb::buildArrowExp(stencil_var, sb::buildVarRefExp(member_decl));
    //const SgInitializedNamePtrList &vars = member_decl->get_variables();
    //GridType *gt = tx_->findGridType(vars[0]->get_type());
    SgType *member_type = si::getFirstVarType(member_decl);
    GridType *gt = tx_->findGridType(member_type);
    if (gt) {
      arg = sb::buildPointerDerefExp(
          sb::buildCastExp(
              BuildGridGetDev(arg),
              sb::buildPointerType(BuildOnDeviceGridType(gt))));
      // skip the grid index
      ++member;
    }
    if (overlap_enabled && Domain::isDomainType(member_type)) {
      args->append_expression(BuildDomainShrink(
          sb::buildAddressOfOp(arg), sb::buildIntVal(overlap_width)));
    } else {
      args->append_expression(arg);
    }
    args_boundary->append_expression(arg);    
  }

  // Generate Kernel invocation code
  SgCudaKernelExecConfig *cuda_config =
      sbx::buildCudaKernelExecConfig(sb::buildVarRefExp(grid_dim),
                                     sb::buildVarRefExp(block_dim),
                                     NULL, NULL);
  if (overlap_enabled) {
    SgVarRefExp *inner_stream = sb::buildVarRefExp("stream_inner");
    PSAssert(inner_stream);
    SgCudaKernelExecConfig *cuda_config_inner =
      sbx::buildCudaKernelExecConfig(sb::buildVarRefExp(grid_dim),
                                     sb::buildVarRefExp(block_dim),
                                     NULL, inner_stream);

    SgFunctionSymbol *fs_inner =
        rose_util::getFunctionSymbol(smap->run_inner());
    SgCudaKernelCallExp *c =
        sbx::buildCudaKernelCallExp(sb::buildFunctionRefExp(fs_inner),
                                    args, cuda_config_inner);
    loop_body->append_statement(sb::buildExprStatement(c));
    // perform boundary exchange concurrently
    FOREACH (sit, load_statements.begin(), load_statements.end()) {
      loop_body->append_statement(*sit);
    }
    LOG_INFO() << "generating call to boundary kernel\n";
    if (overlap_width && !flag_multistream_boundary_) {
      LOG_INFO() << "single-stream version\n";
      SgFunctionSymbol *fs_boundary =
          si::lookupFunctionSymbolInParentScopes(
              smap->getRunName() + GetBoundarySuffix());
      c = sbx::buildCudaKernelCallExp(sb::buildFunctionRefExp(fs_boundary),
                                      args_boundary, cuda_config);
      loop_body->append_statement(sb::buildExprStatement(c));
    } else if (overlap_width) {
      LOG_INFO() << "multi-stream version\n";
      // rose_util::AppendExprStatement(
      //     loop_body,
      //     BuildCudaStreamSynchronize(sb::buildVarRefExp("stream_boundary_copy")));
      SgExpressionPtrList &arg_list = args_boundary->get_expressions();
      SgExpression *dom = arg_list.front();      
      arg_list.erase(arg_list.begin());      
      // 6 streams for
      int stream_index = 0;
      int num_x_streams = 5;
      for (int j = 0; j < 2; ++j) {
        for (int i = 0; i < num_x_streams; ++i) {
          SgExpression *bd =
              BuildDomainGetBoundary(sb::buildAddressOfOp(dom),
                                     0, j, sb::buildIntVal(overlap_width),
                                     num_x_streams, i);
          args_boundary = sb::buildExprListExp(arg_list);
          args_boundary->prepend_expression(bd);
          int dimz = 512 / (overlap_width * 128);
          SgCudaKernelExecConfig *boundary_config =
              sbx::buildCudaKernelExecConfig(
                  sb::buildIntVal(1),
                  BuildCudaDim3(sb::buildIntVal(overlap_width),
                                sb::buildIntVal(128),
                                sb::buildIntVal(dimz)),
                  NULL, BuildStreamBoundaryKernel(stream_index));
          ++stream_index;
          SgFunctionSymbol *fs_boundary
              = si::lookupFunctionSymbolInParentScopes(
                  smap->getRunName() + GetBoundarySuffix(0, j));
          c = sbx::buildCudaKernelCallExp(
              sb::buildFunctionRefExp(fs_boundary),
              args_boundary, boundary_config);
          loop_body->append_statement(sb::buildExprStatement(c));
        }
      }
      for (int j = 1; j < 3; ++j) {
        for (int i = 0; i < 2; ++i) {
          SgExpression *bd =
              BuildDomainGetBoundary(sb::buildAddressOfOp(dom),
                                     j, i, sb::buildIntVal(overlap_width),
                                     1, 0);
          args_boundary = sb::buildExprListExp(arg_list);
          args_boundary->prepend_expression(bd);
          SgCudaKernelExecConfig *boundary_config;
          if (j == 1) {
            int dimz = 512 / (overlap_width * 128);
            boundary_config = sbx::buildCudaKernelExecConfig(
                sb::buildIntVal(1),
                BuildCudaDim3(sb::buildIntVal(128),
                              sb::buildIntVal(overlap_width),
                              sb::buildIntVal(dimz)),
                NULL, BuildStreamBoundaryKernel(stream_index));
          } else {
            boundary_config = sbx::buildCudaKernelExecConfig(
                sb::buildIntVal(1),
                BuildCudaDim3(sb::buildIntVal(128),
                              sb::buildIntVal(4)),
                NULL, BuildStreamBoundaryKernel(stream_index));
          }
          ++stream_index;
          SgFunctionSymbol *fs_boundary
              = si::lookupFunctionSymbolInParentScopes(
                  smap->getRunName() + GetBoundarySuffix(j, i));
          c = sbx::buildCudaKernelCallExp(sb::buildFunctionRefExp(fs_boundary),
                                          args_boundary, boundary_config);
          loop_body->append_statement(sb::buildExprStatement(c));
        }
      }
      loop_body->append_statement(sb::buildExprStatement(
          BuildCudaThreadSynchronize()));
    }
  } else {
    // perform boundary exchange before kernel invocation synchronously
    FOREACH (sit, load_statements.begin(), load_statements.end()) {
      loop_body->append_statement(*sit);
    }
    SgCudaKernelCallExp *c =
        sbx::buildCudaKernelCallExp(sb::buildFunctionRefExp(fs),
                                    args, cuda_config);
    loop_body->append_statement(sb::buildExprStatement(c));
  }
  appendGridSwap(smap, stencil_var, loop_body);
  DeactivateRemoteGrids(smap, stencil_var, loop_body,
                        remote_grids);

  FixGridAddresses(smap, stencil_var, function_body);
}

SgBasicBlock *MPICUDATranslator::generateRunBody(Run *run) {
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by generateRunBody");

  string stencil_param_name = "stencils";
  SgVarRefExp *stencils = sb::buildVarRefExp(stencil_param_name,
                                             block);

  SgVariableDeclaration *block_dim =
      sbx::buildDim3Declaration("block_dim", BuildBlockDimX(),
                                BuildBlockDimY(),  BuildBlockDimZ(),
                                block);
  block->append_statement(block_dim);
  
  // build main loop
  SgBasicBlock *loopBody = sb::buildBasicBlock();
  cache_config_done_.clear();
  ENUMERATE(i, it, run->stencils().begin(), run->stencils().end()) {
    ProcessStencilMap(it->second, stencils, i, run,
                      block, loopBody, block_dim);
  }
  SgVariableDeclaration *lv
      = sb::buildVariableDeclaration("i", sb::buildIntType(), NULL, block);
  block->append_statement(lv);
  SgStatement *loopTest =
      sb::buildExprStatement(
          sb::buildLessThanOp(sb::buildVarRefExp(lv),
                              sb::buildVarRefExp("iter", block)));
  SgForStatement *loop =
      sb::buildForStatement(sb::buildAssignStatement(sb::buildVarRefExp(lv),
                                                     sb::buildIntVal(0)),
                            loopTest,
                            sb::buildPlusPlusOp(sb::buildVarRefExp(lv)),
                            loopBody);

  //block->append_statement(loop);  
  TraceStencilRun(run, loop, block);
  // cudaThreadSynchronize after each loop
  block->insert_statement(
      loop, sb::buildExprStatement(BuildCudaThreadSynchronize()), false);
  

  return block;
}

// NOTE: non-refactorable size is not handled correctly.
// 04/20/2011: Is this fixed?
SgVariableDeclaration *MPICUDATranslator::generateGridDimDeclaration3D(
    const SgName &name,
    SgExpression *stencil_var,
    SgExpression *block_dim_x,
    SgExpression *block_dim_y,
    SgScopeStatement *scope) {
  SgExpression *dim_x, *dim_y, *dim_z;
#if NOMURA_ORIGINAL  
  dim_x =
      sb::buildDivideOp(
          sb::buildMultiplyOp(
              sbx::buildStencilDimVarExp(stencil, stencil_var, 0),
              sbx::buildStencilDimVarExp(stencil, stencil_var, 1)),
          sb::buildMultiplyOp(block_dim_x, block_dim_y));
  dim_y = sb::buildDivideOp(sbx::buildStencilDimVarExp(stencil,
                                                       stencil_var, 2),
                            BuildBlockDimZ());
  dim_z = sb::buildIntVal(1);
#else
  dim_x =
      sb::buildDivideOp(
          sb::buildMultiplyOp(
              BuildStencilDomMaxRef(stencil_var, 0),
              BuildStencilDomMaxRef(stencil_var, 1)),
          sb::buildMultiplyOp(block_dim_x, block_dim_y));
  dim_y = sb::buildDivideOp(BuildStencilDomMaxRef(stencil_var, 2),
                            BuildBlockDimZ());
  dim_z = sb::buildIntVal(1);
#endif  
  SgVariableDeclaration *block_dim =
      sbx::buildDim3Declaration(name, dim_x, dim_y, dim_z, scope);
  return block_dim;
}

SgVariableDeclaration *MPICUDATranslator::generateGridDimDeclaration2D(
    const SgName &name,
    SgExpression *stencil_var,
    SgExpression *block_dim_x,
    SgExpression *block_dim_y,
    SgScopeStatement *scope) {
  // Note: BuildBlockDimX/Y/Z are not used because double values are
  // used here. Casting to double would be ok, but immediate values as
  // double would look nicer.
  SgExpression *dim_x =
      sb::buildCastExp(BuildFunctionCall(
          "ceil",
          sb::buildDivideOp(BuildGetLocalSize(sb::buildIntVal(0)),
                            sb::buildDoubleVal(block_dim_x_))),
                       sb::buildIntType());
  SgExpression *dim_y =
      sb::buildCastExp(BuildFunctionCall(
          "ceil",
          sb::buildDivideOp(BuildGetLocalSize(sb::buildIntVal(1)),
                            sb::buildDoubleVal(block_dim_y_))),
                       sb::buildIntType());
  SgExpression *dim_z = sb::buildIntVal(1);
  SgVariableDeclaration *block_dim =
      sbx::buildDim3Declaration(name, dim_x, dim_y, dim_z, scope);
  return block_dim;
}

SgType *MPICUDATranslator::BuildOnDeviceGridType(GridType *gt) {
  PSAssert(gt);
  string gt_name;
  int nd = gt->getNumDim();
  string elm_name = gt->getElmType()->unparseToString();
  std::transform(elm_name.begin(), elm_name.begin() +1,
                 elm_name.begin(), toupper);
  string ondev_type_name = "__PSGrid" + toString(nd) + "D"
                           + elm_name + "Dev";
  LOG_DEBUG() << "On device grid type name: "
              << ondev_type_name << "\n";
  SgType *t =
      si::lookupNamedTypeInParentScopes(ondev_type_name, global_scope_);
  PSAssert(t);
  return t;
}

static std::string GetTypeDimSig(const std::string &s) {
  for (int i = 1; i <= PS_MAX_DIM; ++i) {
    vector<string> names;
    names.push_back("Float");
    names.push_back("Double");
    FOREACH (it, names.begin(), names.end()) {
      string key = (*it) + toString(i) + "D";
      if (s.find(key) != string::npos) return key;
    }
  }
  return "";
}

void MPICUDATranslator::GenerateInnerKernel(SgFunctionDeclaration *original) {
  // SgFunctionDeclaration *inner_version =
  //     isSgFunctionDeclaration(si::copyStatement(original));
  SgFunctionDeclaration *inner_version =
      rose_util::CloneFunction(original,
                               original->get_name() + inner_prefix_);
  PSAssert(inner_version);
  si::insertStatementBefore(original, inner_version, false);
  Rose_STL_Container<SgNode*> calls =
      NodeQuery::querySubTree(inner_version, V_SgFunctionCallExp);

  FOREACH (it, calls.begin(), calls.end()) {
    SgFunctionCallExp *fc = isSgFunctionCallExp(*it);
    PSAssert(fc);
    SgFunctionDeclaration *decl = fc->getAssociatedFunctionDeclaration();
    PSAssert(decl);
    SgFunctionSymbol *sym = fc->getAssociatedFunctionSymbol();
    PSAssert(sym);
    string name = sym->get_name();
    if (startswith(name, get_addr_name_)) {
      if (startswith(name, get_addr_no_halo_name_)) continue;
      //replace getaddr with getaddrnohalo
      string key = GetTypeDimSig(name);
      PSAssert(key != "");
      name = get_addr_no_halo_name_ + key;
      LOG_INFO() << "Redirecting to " << name << "\n";
      fc->set_function(sb::buildFunctionRefExp(name));
      continue;
    }
    // No redirection for emits
    if (startswith(name, emit_addr_name_)) continue;
    // Redirect intra-kernel calls 
    if (decl->get_definingDeclaration()) {
      fc->set_function(sb::buildFunctionRefExp(name + inner_prefix_));
      continue;
    }
  }
  if (flag_pre_calc_grid_address_) {
    MPICUDAOptimizer opt(*this);
    opt.GridPreCalcAddr(inner_version);
  }
}

static int GetMaximumNumberOfDimensions(SgFunctionDeclaration *func) {
  // TODO: This does not work for intra kernels
  // Possible fix: find the Kernel object, and get the parent
  // func Find The root kernel func, and then use the below logic to
  // get the number of possible max dim.
  SgFunctionParameterList *params = func->get_parameterList();
  SgInitializedNamePtrList &param_args = params->get_args();
  int dim = 0;
  ENUMERATE (i, it, param_args.begin(), param_args.end()) {
    SgInitializedName *p = *it;
    if (!rose_util::IsIntLikeType(p)) {
      dim = i;
      break;
    }
  }
  LOG_DEBUG() << "Kernel (" << string(func->get_name()) << ") max dim: "
              << dim << "\n";
  return dim;
  
}

// Generates per-boundary kernels. 
void MPICUDATranslator::GenerateBoundaryKernel(SgFunctionDeclaration *original) {
  int ndim = GetMaximumNumberOfDimensions(original);
  for (int i = 0; i < ndim; ++i) {
    for (int j = 0; j < 2; ++j) {
      string suffix = GetBoundarySuffix(i, j);
      LOG_INFO() << "Generating device function: "
                  << string(original->get_name() + suffix) << "\n";
      SgFunctionDeclaration *boundary_version =
          rose_util::CloneFunction(original,
                                   original->get_name() + suffix,
                                   global_scope_);
      PSAssert(boundary_version);
      si::insertStatementBefore(original, boundary_version, false);
      Rose_STL_Container<SgNode*> calls =
          NodeQuery::querySubTree(boundary_version, V_SgFunctionCallExp);

      FOREACH (it, calls.begin(), calls.end()) {
        SgFunctionCallExp *fc = isSgFunctionCallExp(*it);
        PSAssert(fc);
        SgFunctionDeclaration *decl = fc->getAssociatedFunctionDeclaration();
        PSAssert(decl);
        SgFunctionSymbol *sym = fc->getAssociatedFunctionSymbol();
        PSAssert(sym);
        string name = sym->get_name();
        if (startswith(name, get_addr_name_)) {
          if (startswith(name, get_addr_no_halo_name_)) continue;
          if (!fc->attributeExists(StencilIndexAttribute::name)) continue;
          const StencilIndexList &sil =
              static_cast<StencilIndexAttribute*>(fc->getAttribute("StencilIndexList"))->stencil_index_list();

          LOG_DEBUG() << "sil: " << sil << "\n";
          // TODO: the kernel might be used for smaller dimension
          // grids, but that kernel is not recognized as regular even
          // if it's really the case because ndim is used as num_dim param.
          if (!StencilIndexRegularOrder(sil, ndim)) continue;
          int offset = sil[i].offset;
          StencilIndexList t = sil;
          t[i].offset = 0;
          if (!StencilIndexSelf(t, ndim)) continue;
          if ((j == 0 && offset < 0) || ((j == 1) && offset > 0)) {
            continue;
          }
          string key = GetTypeDimSig(name);
          PSAssert(key != "");
          name = get_addr_no_halo_name_ + key;
          LOG_INFO() << "Redirecting to " << name << "\n";
          fc->set_function(sb::buildFunctionRefExp(name));
          continue;
        }
        // No redirection for emits
        if (startswith(name, emit_addr_name_)) continue;
        // Redirect intra-kernel calls
        if (decl->get_definingDeclaration()) {
          fc->set_function(sb::buildFunctionRefExp(name + suffix));
          continue;
        }
      }
    }
  }
}


void MPICUDATranslator::translateKernelDeclaration(
    SgFunctionDeclaration *node) {
  LOG_DEBUG() << "Translating to CUDA kernel\n";
  SgFunctionModifier &modifier = node->get_functionModifier();
  modifier.setCudaDevice();

  // e.g., PSGrid3DFloat -> __PSGrid3DFloatDev *
  Rose_STL_Container<SgNode*> exps =
      NodeQuery::querySubTree(node, V_SgInitializedName);
  FOREACH (it, exps.begin(), exps.end()) {
    SgInitializedName *exp = isSgInitializedName(*it);
    PSAssert(exp);
    SgType *cur_type = exp->get_type();
    GridType *gt = tx_->findGridType(cur_type);
    // not a grid type
    if (!gt) continue;
    SgType *new_type = sb::buildPointerType(BuildOnDeviceGridType(gt));
    exp->set_type(new_type);
  }
  
  Rose_STL_Container<SgNode*> gdim_calls =
      NodeQuery::querySubTree(node, V_SgFunctionCallExp);
  SgFunctionSymbol *gdim_dev =
      si::lookupFunctionSymbolInParentScopes("__PSGridDimDev");
  FOREACH (it, gdim_calls.begin(), gdim_calls.end()) {
    SgFunctionCallExp *fc = isSgFunctionCallExp(*it);
    PSAssert(fc);
    if (fc->getAssociatedFunctionSymbol() != grid_dim_get_func_)
      continue;
    fc->set_function(sb::buildFunctionRefExp(gdim_dev));
  }

  if (flag_mpi_overlap_) {
    GenerateInnerKernel(node);
  }

  if (flag_multistream_boundary_) {
    GenerateBoundaryKernel(node);
  }
  
  return;
}
SgFunctionDeclaration *MPICUDATranslator::generateRunKernel(
    StencilMap *stencil) {
  SgFunctionParameterList *params = sb::buildFunctionParameterList();
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  SgInitializedName *grid_arg = NULL;
  SgInitializedName *dom_arg = NULL;

  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();
  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    params->append_arg(sb::buildInitializedName("offset" + toString(i),
                                                sb::buildIntType()));
  }
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = new SgInitializedName(*vars[0]);
    SgType *type = arg->get_type();
    LOG_DEBUG() << "type: " << type->unparseToString() << "\n";
    if (Domain::isDomainType(type)) {
      if (!dom_arg) {
        dom_arg = arg;
      }
    } else if (GridType::isGridType(type)) {
      SgType *gt = BuildOnDeviceGridType(tx_->findGridType(type));
      arg->set_type(gt);
      if (!grid_arg) {
        grid_arg = arg;
      }
      // skip the grid index
      ++member;
    }
    params->append_arg(arg);
  }
  PSAssert(grid_arg);
  PSAssert(dom_arg);

  LOG_INFO() << "Declaring and defining function named "
             << stencil->getRunName() << "\n";
  SgFunctionDeclaration *run_func =
      sb::buildDefiningFunctionDeclaration(stencil->getRunName(),
                                           sb::buildVoidType(),
                                           params, global_scope_);
  
  si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
  SgFunctionModifier &modifier = run_func->get_functionModifier();
  modifier.setCudaKernel();
  SgBasicBlock *func_body = generateRunKernelBody(stencil, grid_arg, dom_arg);
  run_func->get_definition()->set_body(func_body);

  return run_func;
}

SgFunctionDeclaration *MPICUDATranslator::generateRunInnerKernel(
    StencilMap *stencil) {

  if (!flag_mpi_overlap_) return NULL;
  
  SgFunctionParameterList *params = sb::buildFunctionParameterList();
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  SgInitializedName *grid_arg = NULL;
  SgInitializedName *dom_arg = NULL;

  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();
  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    params->append_arg(sb::buildInitializedName("offset" + toString(i),
                                                sb::buildIntType()));
  }
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = new SgInitializedName(*vars[0]);
    SgType *type = arg->get_type();
    LOG_DEBUG() << "type: " << type->unparseToString() << "\n";
    if (Domain::isDomainType(type)) {
      if (!dom_arg) {
        dom_arg = arg;
      }
    } else if (GridType::isGridType(type)) {
      SgType *gt = BuildOnDeviceGridType(tx_->findGridType(type));
      arg->set_type(gt);
      if (!grid_arg) {
        grid_arg = arg;
      }
      // skip the grid index
      ++member;
    }
    params->append_arg(sb::buildInitializedName(arg->get_name(),
                                                arg->get_type()));
  }
  PSAssert(grid_arg);
  PSAssert(dom_arg);

  string func_name = stencil->getRunName() + inner_prefix_;
  LOG_INFO() << "Declaring and defining function named "
             << func_name << "\n";
  SgFunctionDeclaration *run_func =
      sb::buildDefiningFunctionDeclaration(func_name,
                                           sb::buildVoidType(),
                                           params, global_scope_);
  
  si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
  SgFunctionModifier &modifier = run_func->get_functionModifier();
  modifier.setCudaKernel();
  SgBasicBlock *func_body =
      generateRunInnerKernelBody(stencil, grid_arg, dom_arg);
  run_func->get_definition()->set_body(func_body);

  return run_func;
}

void MPICUDATranslator::BuildFunctionParamList(
    SgClassDefinition *param_struct_def,
    SgFunctionParameterList *&params,
    SgInitializedName *&grid_arg,
    SgInitializedName *&dom_arg) {
  LOG_DEBUG() << "Building function parameter list\n";
  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();

  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = new SgInitializedName(*vars[0]);
    SgType *type = arg->get_type();
    if (Domain::isDomainType(type)) {
      if (!dom_arg) {
        dom_arg =  sb::buildInitializedName(arg->get_name(),
                                            arg->get_type());
      }
    } else if (GridType::isGridType(type)) {
      SgType *gt = BuildOnDeviceGridType(tx_->findGridType(type));
      arg->set_type(gt);
      if (!grid_arg) {
        grid_arg = sb::buildInitializedName(arg->get_name(),
                                            arg->get_type());
        
      }
      // skip the grid index
      ++member;
    }
    params->append_arg(sb::buildInitializedName(arg->get_name(),
                                                arg->get_type()));
  }
  return;
}

std::vector<SgFunctionDeclaration*>
MPICUDATranslator::generateRunMultiStreamBoundaryKernel(
    StencilMap *stencil) {
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  std::vector<SgFunctionDeclaration*> run_funcs;

  for (int i = 0; i < stencil->getNumDim(); ++i) {
    for (int j = 0; j < 2; ++j) {
      bool fw = j;
      string name = stencil->getRunName() + GetBoundarySuffix(i, fw);
      LOG_INFO() << "Generating global function: " << name << "\n";
      SgFunctionParameterList *params = sb::buildFunctionParameterList();
      SgInitializedName *grid_arg = NULL;
      SgInitializedName *dom_arg = NULL;
      BuildFunctionParamList(param_struct_def, params,
                             grid_arg, dom_arg);
      PSAssert(dom_arg);
      SgFunctionDeclaration *run_func =
          sb::buildDefiningFunctionDeclaration(
              name, sb::buildVoidType(),
              params, global_scope_);
      si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
      SgFunctionModifier &modifier = run_func->get_functionModifier();
      modifier.setCudaKernel();
      SgBasicBlock *func_body = generateRunMultiStreamBoundaryKernelBody(
          stencil, grid_arg, dom_arg, i, j);
      run_func->get_definition()->set_body(func_body);
      run_funcs.push_back(run_func);
    }
  }
  return run_funcs;
}

std::vector<SgFunctionDeclaration*> MPICUDATranslator::generateRunBoundaryKernel(
    StencilMap *stencil) {
  std::vector<SgFunctionDeclaration*> run_funcs;
  if (!flag_mpi_overlap_) return run_funcs;;
  if (flag_multistream_boundary_)
    return generateRunMultiStreamBoundaryKernel(stencil);

  SgFunctionParameterList *params = sb::buildFunctionParameterList();
  SgClassDefinition *param_struct_def = stencil->GetStencilTypeDefinition();
  PSAssert(param_struct_def);

  SgInitializedName *grid_arg = NULL;
  SgInitializedName *dom_arg = NULL;

  const SgDeclarationStatementPtrList &members =
      param_struct_def->get_members();

  // add offset for process
  for (int i = 0; i < stencil->getNumDim()-1; ++i) {
    params->append_arg(sb::buildInitializedName("offset" + toString(i),
                                                sb::buildIntType()));
  }

  params->append_arg(sb::buildInitializedName(boundary_kernel_width_name_,
                                              sb::buildIntType()));
  
  FOREACH(member, members.begin(), members.end()) {
    SgVariableDeclaration *member_decl = isSgVariableDeclaration(*member);
    const SgInitializedNamePtrList &vars = member_decl->get_variables();
    SgInitializedName *arg = new SgInitializedName(*vars[0]);
    SgType *type = arg->get_type();
    LOG_DEBUG() << "type: " << type->unparseToString() << "\n";
    if (Domain::isDomainType(type)) {
      if (!dom_arg) {
        dom_arg = arg;
      }
    } else if (GridType::isGridType(type)) {
      SgType *gt = BuildOnDeviceGridType(tx_->findGridType(type));
      arg->set_type(gt);
      if (!grid_arg) {
        grid_arg = arg;
      }
      // skip the grid index
      ++member;
    }
    params->append_arg(arg);
  }
  PSAssert(grid_arg);
  PSAssert(dom_arg);

  LOG_INFO() << "Declaring and defining function named "
             << stencil->getRunName() << "\n";
  SgFunctionDeclaration *run_func =
      sb::buildDefiningFunctionDeclaration(stencil->getRunName()
                                           + boundary_suffix_,
                                           sb::buildVoidType(),
                                           params, global_scope_);
  
  si::attachComment(run_func, "Generated by " + string(__FUNCTION__));
  SgFunctionModifier &modifier = run_func->get_functionModifier();
  modifier.setCudaKernel();
  SgBasicBlock *func_body = generateRunBoundaryKernelBody(
      stencil, grid_arg, dom_arg);
  run_func->get_definition()->set_body(func_body);
  run_funcs.push_back(run_func);
  return run_funcs;
}

// same as cuda version
SgFunctionCallExp *MPICUDATranslator::generateKernelCall(
    StencilMap *stencil,
    SgExpressionPtrList &index_args) {
  SgExprListExp *args  = generateKernelCallArgList(stencil, index_args);
  SgFunctionCallExp *func_call =
      sb::buildFunctionCallExp(
          rose_util::getFunctionSymbol(stencil->getKernel()), args);
  return func_call;
}

SgExprListExp *MPICUDATranslator::generateKernelCallArgList(
    StencilMap *stencil,
    SgExpressionPtrList &index_args) {
  SgClassDefinition *stencil_def = stencil->GetStencilTypeDefinition();

  // append the fields of the stencil type to the argument list
  SgExprListExp *args = sb::buildExprListExp();
  FOREACH(it, index_args.begin(), index_args.end()) {
    args->append_expression(*it);
  }
  SgDeclarationStatementPtrList &members = stencil_def->get_members();
  FOREACH(it, ++(members.begin()), members.end()) {
    SgVariableDeclaration *var_decl = isSgVariableDeclaration(*it);
    PSAssert(var_decl);
    SgExpression *exp = sb::buildVarRefExp(var_decl);
    SgVariableDefinition *var_def = var_decl->get_definition();
    PSAssert(var_def);
    SgTypedefType *var_type = isSgTypedefType(var_def->get_type());
    if (GridType::isGridType(var_type)) {
      exp = sb::buildAddressOfOp(exp);
      // skip the grid index field
      ++it;
    }
    args->append_expression(exp);
  }

  // SgFunctionCallExp *func_call =
  //     sb::buildFunctionCallExp(
  //         rose_util::getFunctionSymbol(stencil->getKernel()), args);
  //return func_call;
  return args;
}

SgBasicBlock* MPICUDATranslator::generateRunMultiStreamBoundaryKernelBody(
    StencilMap *stencil,
    SgInitializedName *grid_arg,
    SgInitializedName *dom_arg, int dim, bool fw) {
  LOG_DEBUG() << "Generating run boundary kernel body\n";
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  SgExpression *domain = sb::buildVarRefExp(dom_arg);
  SgExpression *min_field = BuildDomMinRef(domain);
  SgExpression *max_field = BuildDomMaxRef(domain);
  
  SgExpressionPtrList index_args;
  PSAssert(stencil->getNumDim() == 3);

  // Generate a z-loop
  SgVariableDeclaration *loop_index;
  SgStatement *loop_init, *loop_test;
  SgExpression *loop_incr;
  SgBasicBlock *loop_body;
  SgVariableDeclaration *x_index, *y_index, *z_index;
  x_index = sb::buildVariableDeclaration("x", sb::buildIntType(),
                                         NULL, block);
  y_index = sb::buildVariableDeclaration("y", sb::buildIntType(),
                                         NULL, block);
  z_index = sb::buildVariableDeclaration("z", sb::buildIntType(),
                                         NULL, block);
  block->append_statement(x_index);    
  block->append_statement(y_index);
  block->append_statement(z_index);

  index_args.push_back(sb::buildVarRefExp(x_index));
  index_args.push_back(sb::buildVarRefExp(y_index));
  index_args.push_back(sb::buildVarRefExp(z_index));  

  // x = blockIdx.x * blockDim.x + threadIdx.x;
  SgExpression *dom_min_x = sb::buildPntrArrRefExp(min_field,
                                                   sb::buildIntVal(0));
  SgExpression *dom_max_x = sb::buildPntrArrRefExp(max_field,
                                                   sb::buildIntVal(0));
  SgExpression *dom_min_y = sb::buildPntrArrRefExp(min_field,
                                                   sb::buildIntVal(1));
  SgExpression *dom_max_y = sb::buildPntrArrRefExp(max_field,
                                                   sb::buildIntVal(1));
  SgExpression *dom_min_z = sb::buildPntrArrRefExp(min_field,
                                                   sb::buildIntVal(2));
  SgExpression *dom_max_z = sb::buildPntrArrRefExp(max_field,
                                                   sb::buildIntVal(2));
  loop_index = x_index;
  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),
      sb::buildAddOp(sbx::buildCudaIdxExp(sbx::kThreadIdxX),
                     dom_min_x));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          dom_max_x));
  loop_incr =
      sb::buildPlusAssignOp(sb::buildVarRefExp(loop_index),
                            sbx::buildCudaIdxExp(sbx::kBlockDimX));

  loop_body = sb::buildBasicBlock();
  SgExprListExp *kernel_args= generateKernelCallArgList(stencil, index_args);
  string kernel_name = stencil->getKernel()->get_name()
      + GetBoundarySuffix(dim, fw);
  SgFunctionDeclaration *kernel =
      sb::buildNondefiningFunctionDeclaration(
          kernel_name,
          stencil->getKernel()->get_type()->get_return_type(),
          stencil->getKernel()->get_parameterList(),
          global_scope_);
  SgFunctionCallExp *kernel_call =
      sb::buildFunctionCallExp(sb::buildFunctionRefExp(kernel), kernel_args);
  loop_body->append_statement(sb::buildExprStatement(kernel_call));

  SgStatement *loop
      = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);

  loop_index = y_index;
  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),
      sb::buildAddOp(sbx::buildCudaIdxExp(sbx::kThreadIdxY),
                     dom_min_y));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          dom_max_y));
  loop_incr =
      sb::buildPlusAssignOp(sb::buildVarRefExp(loop_index),
                            sbx::buildCudaIdxExp(sbx::kBlockDimY));

  loop = sb::buildForStatement(loop_init, loop_test, loop_incr, loop);

  loop_index = z_index;
  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),
      sb::buildAddOp(sbx::buildCudaIdxExp(sbx::kThreadIdxZ),
                     dom_min_z));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          dom_max_z));
  loop_incr =
      sb::buildPlusAssignOp(sb::buildVarRefExp(loop_index),
                            sbx::buildCudaIdxExp(sbx::kBlockDimZ));
  loop = sb::buildForStatement(loop_init, loop_test, loop_incr, loop);
  
  block->append_statement(loop);

  return block;
}

bool MPICUDATranslator::translateGetKernel(SgFunctionCallExp *node,
                                           SgInitializedName *gv) {
  // 
  // *((gt->getElmType())__PSGridGetAddressND(g, x, y, z))

  GridType *gt = tx_->findGridType(gv->get_type());
  int nd = gt->getNumDim();
  SgScopeStatement *scope = getContainingScopeStatement(node);  
  SgVarRefExp *g = sb::buildVarRefExp(gv->get_name(), scope);
  
  string get_address_name = get_addr_name_ +  GetTypeDimName(gt);
  string get_address_no_halo_name = get_addr_no_halo_name_ +  GetTypeDimName(gt);
  SgFunctionRefExp *get_address = NULL;
  const StencilIndexList *sil = tx_->findStencilIndex(node);
  PSAssert(sil);
  LOG_DEBUG() << "Stencil index: " << *sil << "\n";
  if (StencilIndexSelf(*sil, nd)) {
    get_address = sb::buildFunctionRefExp(get_address_no_halo_name,
                                          global_scope_);
  } else if (StencilIndexRegularOrder(*sil, nd)) {
    for (int i = 0; i < nd; ++i) {
      int offset = (*sil)[i].offset;
      if (!offset) continue;
      string method_name = 
          get_address_name + "_" +
          toString(i) + "_" + ((offset < 0) ? "bw" : "fw");
      LOG_INFO() << "Using " << method_name << "\n";
      get_address = sb::buildFunctionRefExp(method_name, global_scope_);
      break;
    }
  } else {
    get_address = sb::buildFunctionRefExp(get_address_name,
                                          global_scope_);
  }
  SgExprListExp *args = sb::buildExprListExp(g);
  FOREACH (it, node->get_args()->get_expressions().begin(),
           node->get_args()->get_expressions().end()) {
    args->append_expression(si::copyExpression(*it));
  }

  SgFunctionCallExp *get_address_exp
      = sb::buildFunctionCallExp(get_address, args);
  // refactoring: merge the two attributes
  get_address_exp->setAttribute(StencilIndexAttribute::name,
                                new StencilIndexAttribute(*sil));
  get_address_exp->setAttribute(GridCallAttribute::name,
                                node->getAttribute(GridCallAttribute::name));
  SgExpression *x = sb::buildPointerDerefExp(get_address_exp);
  si::replaceExpression(node, x);
  return true;
}

} // namespace translator
} // namespace physis
