// Licensed under the BSD license. See LICENSE.txt for more details.

#include "translator/mpi_opencl_translator.h"
#include "translator/translation_context.h"
#include "translator/translation_util.h"
#include "translator/rose_util.h"
#include "translator/rose_ast_attribute.h"

namespace pu = physis::util;
namespace sb = SageBuilder;
namespace si = SageInterface;


namespace physis {
namespace translator {


void MPIOpenCLTranslator::Define_and_Construct_griddom_in_device(
    StencilMap *stencil,
    SgInitializedName *dom_arg,
    SgScopeStatement *scope
                                                                 )
{
  // Find out grid type, then construct device grid type
  {
    SgClassDefinition *stencil_def = stencil->GetStencilTypeDefinition();
    SgDeclarationStatementPtrList &members = stencil_def->get_members();
    FOREACH(it, ++(members.begin()), members.end()) {
      SgVariableDeclaration *var_decl = isSgVariableDeclaration(*it);
      PSAssert(var_decl);

      SgVarRefExp *exp = sb::buildVarRefExp(var_decl);
      SgVariableDefinition *var_def = var_decl->get_definition();
      PSAssert(var_def);
      SgTypedefType *var_type = isSgTypedefType(var_def->get_type());
      if (!GridType::isGridType(var_type)) continue; // No needed

      std::string var_name = exp->get_symbol()->get_name().getString();
      GridType *gt = tx_->findGridType(var_type);
      SgType *type_dev = BuildOnDeviceGridType(gt, 1);
      SgVariableDeclaration *dec_grid_dev = 
          sb::buildVariableDeclaration(
              var_name, type_dev, NULL, scope
                                       );
      si::appendStatement(dec_grid_dev, scope);
      {
        SgExprListExp* args_st = sb::buildExprListExp();
        si::appendExpression(args_st, 
                             sb::buildAddressOfOp(sb::buildVarRefExp(dec_grid_dev)));

        // Actually macro, however...
        {
          SgExprListExp *args_g = sb::buildExprListExp();
          si::appendExpression(args_g,
                               sb::buildVarRefExp(dec_grid_dev));
          SgFunctionCallExp *exp_macro_gtype =
              sb::buildFunctionCallExp(
                  sb::buildFunctionRefExp("__PS_CL_ARG_EXPAND_ELEMENT_G"), args_g);
          si::appendExpression(args_st, exp_macro_gtype);
        }


        // __PS_CL_construct_PSGrid_from_arg(&ga,__PS_CL_ARG_EXPAND_ELEMENT_G(ga));
        std::string callname = "__PS_CL_construct_PSGrid_from_arg";
        {
          SgType *ty = gt->getElmType();
          if (isSgTypeDouble(ty))
            callname += "_DOUBLE";
        }
        SgFunctionCallExp *exp_fcall =
            sb::buildFunctionCallExp(
                sb::buildFunctionRefExp(callname),
                args_st
                                     );
        si::appendStatement(sb::buildExprStatement(exp_fcall), scope);
      }
    
    } // FOREACH(it, ++(members.begin()), members.end())
  }

  { // For dom type
    std::string dom_name = dom_arg->get_name().getString();
    SgVariableDeclaration *dec_dom_dev = 
        sb::buildVariableDeclaration(
            dom_name, BuildOnDeviceDomType(), NULL, scope);
    si::appendStatement(dec_dom_dev, scope);

    {
      SgExprListExp* args_st = sb::buildExprListExp();
      si::appendExpression(args_st, 
                           sb::buildAddressOfOp(sb::buildVarRefExp(dec_dom_dev)));

      // Actually macro, however...
      {
        SgExprListExp *args_d = sb::buildExprListExp();
        si::appendExpression(args_d,
                             sb::buildVarRefExp(dec_dom_dev));
        SgFunctionCallExp *exp_macro_dom =
            sb::buildFunctionCallExp(
                sb::buildFunctionRefExp("__PS_CL_ARG_EXPAND_ELEMENT_DOM"), args_d);
        si::appendExpression(args_st, exp_macro_dom);
      }


      // __PS_CL_construct_PSDomain_from_arg(&ga,__PS_CL_ARG_EXPAND_ELEMENT_DOM(ga));
      SgFunctionCallExp *exp_fcall =
          sb::buildFunctionCallExp(
              sb::buildFunctionRefExp("__PS_CL_construct_PSDomain_from_arg"),
              args_st
                                   );
      si::appendStatement(sb::buildExprStatement(exp_fcall), scope);
    }
  }
}


// This is the same as CUDATranslator::BuildRunKernelBody, except for
// this version needs to add offsets to the x and y indices.
SgBasicBlock* MPIOpenCLTranslator::BuildRunKernelBody(
    StencilMap *stencil,
    SgInitializedName *dom_arg) {

  LOG_DEBUG() << __FUNCTION__;
  // Basic scope
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));

  int dim = stencil->getNumDim();  
  SgExpression *domain = sb::buildVarRefExp(dom_arg);
  SgExpression *min_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_min"));
  SgExpression *max_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_max"));
  vector<SgExpression*> offset_exprs;
  for (int i = 0; i < dim-1; ++i) {
    offset_exprs.push_back(sb::buildVarRefExp("offset" + toString(i)));
  }
  
  SgExpressionPtrList index_args;
  if (dim < 3) {
    LOG_ERROR() << "not supported yet.\n";
  } else if (dim == 3) {

    // Construct device innder grid and domain
    Define_and_Construct_griddom_in_device(stencil, dom_arg, block);

    // Declare x, y, z
    SgVariableDeclaration *x_index = sb::buildVariableDeclaration
        ("x", sb::buildLongType(), NULL, block);
    SgVariableDeclaration *y_index = sb::buildVariableDeclaration
        ("y", sb::buildLongType(), NULL, block);
    SgVariableDeclaration *z_index = sb::buildVariableDeclaration
        ("z", sb::buildLongType(), NULL, block);

    si::appendStatement(x_index, block);    
    si::appendStatement(y_index, block);

    index_args.push_back(sb::buildVarRefExp(x_index));
    index_args.push_back(sb::buildVarRefExp(y_index));

    // x = get_global_id(0) + offset0
    x_index->reset_initializer(
        sb::buildAssignInitializer(
            sb::buildAddOp(
                BuildFunctionCall(
                    "get_global_id", sb::buildIntVal(0)
                                  ),
                offset_exprs[0])));

    // y = blockIdx.y * blockDim.y + threadIdx.y + offset.y;
    y_index->reset_initializer(
        sb::buildAssignInitializer(
            sb::buildAddOp(
                BuildFunctionCall(
                    "get_global_id", sb::buildIntVal(1)
                                  ),
                offset_exprs[1])));

    SgVariableDeclaration *loop_index = z_index;
    // z = dom.local_min[2];
    SgStatement *loop_init = sb::buildAssignStatement(
        sb::buildVarRefExp(loop_index),
        sb::buildPntrArrRefExp(min_field, sb::buildIntVal(2)));
    // z <= dom.local_min[2];
    SgStatement *loop_test = sb::buildExprStatement(
        sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                            sb::buildPntrArrRefExp(max_field,
                                                   sb::buildIntVal(2))));
    index_args.push_back(sb::buildVarRefExp(loop_index));

    SgVariableDeclaration* t[] = {x_index, y_index};
    vector<SgVariableDeclaration*> range_checking_idx(t, t + 2);
    si::appendStatement(
        BuildDomainInclusionCheck(range_checking_idx, domain),
        block);
    
    si::appendStatement(loop_index, block);

    // z++;
    SgExpression *loop_incr =
        sb::buildPlusPlusOp(sb::buildVarRefExp(loop_index));
    SgFunctionCallExp *kernel_call
        = BuildKernelCall(stencil, index_args);
    SgBasicBlock *loop_body =
        sb::buildBasicBlock(sb::buildExprStatement(kernel_call));
    SgStatement *loop
        = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);
    si::appendStatement(loop, block);
  }

  return block;
}

SgBasicBlock* MPIOpenCLTranslator::BuildRunInteriorKernelBody(
    StencilMap *stencil, SgInitializedName *dom_arg) {
  LOG_DEBUG() << "Generating run stencil interior kernel body\n";  

  // Reuse BuildRunKernelBody function, and then redirect calls to
  // the inner kernel function
  
  SgBasicBlock *body = BuildRunKernelBody(stencil, dom_arg);
  const std::string &normal_kernel_name = stencil->getKernel()->get_name();
  const std::string &inner_kernel_name = normal_kernel_name 
      + inner_prefix_;
  LOG_DEBUG() << "normal kernel name: " << normal_kernel_name << "\n";
  LOG_DEBUG() << "inner kernel name: " << inner_kernel_name << "\n";
  SgFunctionDeclaration *inner_kernel =
      sb::buildNondefiningFunctionDeclaration(
          inner_kernel_name,
          stencil->getKernel()->get_type()->get_return_type(),
          stencil->getKernel()->get_parameterList(),
          global_scope_);
  
  rose_util::RedirectFunctionCalls
      (body, normal_kernel_name, inner_kernel);
  return body;
}

SgBasicBlock* MPIOpenCLTranslator::BuildRunBoundaryKernelBody(
    StencilMap *stencil, SgInitializedName *dom_arg) {
  LOG_DEBUG() << "Generating run boundary kernel body\n";
  SgBasicBlock *block = sb::buildBasicBlock();
  si::attachComment(block, "Generated by " + string(__FUNCTION__));
  int dim = stencil->getNumDim();  
  SgExpression *domain = sb::buildVarRefExp(dom_arg);
  SgExpression *min_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_min"));
  SgExpression *max_field = sb::buildDotExp(
      sb::buildVarRefExp(dom_arg), sb::buildVarRefExp("local_max"));
  SgExpression *width = sb::buildVarRefExp(boundary_kernel_width_name_);
  vector<SgExpression*> offset_exprs;
  for (int i = 0; i < dim-1; ++i) {
    offset_exprs.push_back(sb::buildVarRefExp("offset" + toString(i)));
  }
  
  SgExpressionPtrList index_args;
  if (dim < 3) {
    LOG_ERROR() << "not supported yet.\n";
    PSAbort(1);
  }


  // Construct device innder grid and domain
  Define_and_Construct_griddom_in_device(stencil, dom_arg, block);

  SgVariableDeclaration *x_index = sb::buildVariableDeclaration
      ("x", sb::buildLongType(), NULL, block);
  SgVariableDeclaration *y_index = sb::buildVariableDeclaration
      ("y", sb::buildLongType(), NULL, block);
  SgVariableDeclaration *z_index = sb::buildVariableDeclaration
      ("z", sb::buildLongType(), NULL, block);

  si::appendStatement(x_index, block);    
  si::appendStatement(y_index, block);

  index_args.push_back(sb::buildVarRefExp(x_index));
  index_args.push_back(sb::buildVarRefExp(y_index));

  // x = get_global_id(0) + offset0;
  SgExpression *dom_min_z = sb::buildPntrArrRefExp(min_field,
                                                   sb::buildIntVal(2));
  SgExpression *dom_max_z = sb::buildPntrArrRefExp(max_field,
                                                   sb::buildIntVal(2));
  x_index->reset_initializer(
      sb::buildAssignInitializer(
          sb::buildAddOp(
              BuildFunctionCall(
                  "get_global_id", sb::buildIntVal(0)
                                ),
              offset_exprs[0])));
      

  // y = get_global_id(1) + offset1
  y_index->reset_initializer(
      sb::buildAssignInitializer(
          sb::buildAddOp(
              BuildFunctionCall(
                  "get_global_id", sb::buildIntVal(1)
                                ),
              offset_exprs[1])));
  
  SgVariableDeclaration *loop_index = z_index;      
  SgStatement *loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index), dom_min_z);
  SgStatement *loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildAddOp(dom_min_z, width)));
  
  index_args.push_back(sb::buildVarRefExp(loop_index));

  SgVariableDeclaration* t[] = {x_index, y_index};
  vector<SgVariableDeclaration*> range_checking_idx(t, t + 2);
    
  si::appendStatement(
      BuildDomainInclusionCheck(range_checking_idx, domain),
      block);
    
  si::appendStatement(loop_index, block);

  SgExpression *loop_incr =
      sb::buildPlusPlusOp(sb::buildVarRefExp(loop_index));
  SgFunctionCallExp *kernel_call
      = BuildKernelCall(stencil, index_args);
  SgBasicBlock *loop_body = sb::buildBasicBlock(
      sb::buildExprStatement(kernel_call));
  SgStatement *loop
      = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);
  si::appendStatement(loop, block);

  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index),  sb::buildAddOp(dom_min_z, width));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          sb::buildSubtractOp(dom_max_z, width)));
  loop = sb::buildForStatement(loop_init, loop_test,
                               loop_incr, loop_body);
  si::appendStatement(
      BuildDomainInclusionInnerCheck(
          range_checking_idx, domain, width, loop),
      block);

  loop_init = sb::buildAssignStatement(
      sb::buildVarRefExp(loop_index), sb::buildSubtractOp(dom_max_z,
                                                          width));
  loop_test = sb::buildExprStatement(
      sb::buildLessThanOp(sb::buildVarRefExp(loop_index),
                          dom_max_z));
  loop = sb::buildForStatement(loop_init, loop_test, loop_incr, loop_body);
  si::appendStatement(loop, block);

  return block;
}


} // namespace translator
} // namespace physis
